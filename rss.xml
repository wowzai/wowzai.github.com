<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>wowzai&#39;s blog</title>
    <link>http://www.wowzai.com</link>
    <pubDate>08 Sep 14 22:48 CST</pubDate>
    <item>
      <title>年轻真好</title>
      <link>http://www.wowzai.com/2014/young.html</link>
      <pubDate>2014-09-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;昨天爬完三清山，因为很长时间没有运动，虽然爬山的过程不是那么的吃力，但是以为第二天起来应该会酸痛，但是今天早上起来，发现没啥感觉，没觉得哪里酸哪里痛，突然发现年轻真好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们以五年的眼光来看的话,我们现在要做什么重要的事情，我们应该好好想一想，这样在五年之后才会得到想要的生活，最起码是接近。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本来想写很多，但是突然发现似乎又没有那么多要写的，呵呵，蛮好玩的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;趁着还年轻，多做一些事情，多做一些不会让自己后悔的事情，趁还能干得动的时候。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;观察自己是一件非常有趣的事情，有无数的乐趣可以体会到，真的很好玩。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>2014.09计划</title>
      <link>http://www.wowzai.com/2014/plan-of-2014-09.html</link>
      <pubDate>2014-09-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;废话不多说，先来总结上个月的计划完成情况：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.看完第四章：Oracle里的查询转换   完成50%，后期由于买房事宜耽误，但其实我知道这不是真正的理由&#xA;&#xA;2.游泳十次                       未完成，游泳三次，由于天气原因+发版计划，未能完成&#xA;&#xA;3.写三遍bolg                     完成，如果严格的话把买房的博文剔除的话，还是未完成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;首先，正视自己，诚实地面对自己，不再对自己定好高骛远的计划了，定了也没用，根本完不成，现在我需要更加务实地去制定计划，&#xA;我需要真正落地的计划，而不是完不成的to-do list。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;8月的主要时间是花在了买房的事宜上，包括看房、选择、权衡以及集资。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;9月的计划：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.看完第四章：Oracle里的查询转换&#xA;&#xA;2.跑步5公里&#xA;&#xA;3.写三篇blog&#xA;&#xA;4.跟着奶爸的学习方法，学完音标、English through Pictures 3本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;希望月底的时候能比8月有进步，对，只要有进步就OK。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>买房2</title>
      <link>http://www.wowzai.com/2014/buy-house-2.html</link>
      <pubDate>2014-08-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自从上次决定买房之后，这几个星期主要精力都用在了买房之上，我先是看了御景蓝湾的房子，看了他们的样板房，觉得挺好的，于是才决定买的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后来我老婆去看了一下，也觉得挺好的，只不过发现周围好多进城的卡车，尘土飞扬，觉得不安全，不卫生，我想也是，主要是不安全，以后小孩上学的路上碰到卡车多危险，卫不卫生倒不是很重要，起码对于我来说不是很重要。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是那时候已经决定买房了，所以周末（2014.8.16）就回家了，问家里人集点资，为马上的买房行为做好准备。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后来老婆在星光大道转悠，发现泊林春天的广告，两个人回来仔细的研究了一下，最后一致的认为这个地段比御景蓝湾的要好，唯一担心的就是价格，&#xA;因为那个时候还没开盘，价格还没公布，最后我还是让老婆先去看一下，后来由于各种原因，老婆也没有去看成，最后老婆建议我请个半天假我们两个人一起去看一下，我觉得也对，于是就上个星期二（2014.8.19）我请了下午的假，两个人一起去看了一下房子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那天天空不作美啊，下着雨，我们转了两次公交后终于到达目的地，在其中一次等公交的时候离楼盘不是很远，周围都是各种楼盘，然后我们几乎把周围的楼盘的电话打了个遍，尼玛，发现都买不起，晕。到了目的地之后，下车之后在你那荒郊野外的地方根本不知道怎么走，尼玛，老婆说不买了，太偏了啥的，我说既然都来了，先看了再说。于是找了又找，终于回头一看发现了楼盘的售楼处，两个人这才进去。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进去以后，一个售楼小姐开始招待我们，后来另一个售楼先生给我老婆打电话（来的路上给他打过电话没接），然后那个男的开始招待我们，两位交接的时候我看到售楼小姐难看的脸色，呵呵。介绍的过程就不表了，就是讲解了一下楼盘的位置，周围的设施等等，然后去看了样板房，对于样板房也表满意，除了厨房的设计，再后来就是聊了一会，基本就是我们问一些问题，他向我们介绍一下，然后我们就签了一个交5000抵20000的协议并把钱交了，之后就出来了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来就是比较回去了，找了下公交，发现有更加方便的公交，不过还是要转一次车，然后就是一起吃了个饭，你以为这个时候是要快快乐乐的回家了吗，当然不，一想到即将到来的债务，尼玛，我又乖乖的回到公司加班了，哈哈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;未完待续……&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>买房1</title>
      <link>http://www.wowzai.com/2014/buy-house-1.html</link>
      <pubDate>2014-08-10 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;决定买房了，嗯，就这样。&lt;/h3&gt;&#xA;</description>
    </item>
    <item>
      <title>2014.08计划</title>
      <link>http://www.wowzai.com/2014/plan-of-2014-08.html</link>
      <pubDate>2014-08-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从今年的五月份开始，每个月我都给自己订立计划，经过三个月的失败（2014.05、2014.06、2014.07），我彻底醒悟，发现我&#xA;之前订立的计划根本没有一个月是完全完成的，我分析了一下，主要有两个原因：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.加班太忙，几乎每天加班，导致没有自己的时间干自己的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.时间没有分配好，有时候闲了一下，还不知道干什么，这个时候最容易偷懒。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.效率太低，单位时间活干的较少，这其实涉及到自己基本功的问题，基本功不扎实导致学东西的时候效率较低，&#xA;这个还得慢慢来补。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;鉴于前面三个月的失败案例，决定从这个月起，将计划减少，不要设置很多个计划，到最后都没有完成。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;看完第四章：Oracle里的查询转换&#xA;&#xA;游泳十次&#xA;&#xA;写三遍bolg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>golang中获取中文字符串的子串字符位置及截取子串</title>
      <link>http://www.wowzai.com/2014/chinese-string-in-golang.html</link>
      <pubDate>2014-08-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;昨天准备用golang做一个简单的文本分析，需要简单的对字符串进行一些操作，在查看了strings和strconv库时，我没找到截取字符串的函数，同时strings.Index返回的是子串的字节位置，例如这个例子：strings.Index(&amp;ldquo;早上好，张先生！&amp;rdquo;,&amp;ldquo;好&amp;rdquo;) 的返回值是6，而不是2（从0开始算）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是我自己写了一个处理中文的返回字符串子串位置的函数，思想其实很简单，首先通过strings库中的Index函数获得子串的字节位置，再通过这个位置获得子串之前的字节数组pre，再将pre转换成[]rune，获得[]rune的长度，便是子串之前字符串的长度，也就是子串在字符串中的字符位置，具体代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func UnicodeIndex(str,substr string) int {&#xA;  // 子串在字符串的字节位置&#xA;  result := strings.Index(str,substr)  &#xA;  if result &amp;gt;= 0 {&#xA;    // 获得子串之前的字符串并转换成[]byte&#xA;    prefix := []byte(str)[0:result]  &#xA;    // 将子串之前的字符串转换成[]rune&#xA;    rs := []rune(string(prefix))  &#xA;    // 获得子串之前的字符串的长度，便是子串在字符串的字符位置&#xA;    result = len(rs)&#xA;  }&#xA;&#xA;  return result&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意，这里用的是string.Index函数，类似的，也可以写中文字符串的类似strings中的IndexAny,LastIndex等函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的思想，我也写了一个截取中文字符串的函数，如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func SubString(str string,begin,length int) (substr string) {&#xA;  // 将字符串的转换成[]rune&#xA;  rs := []rune(str)&#xA;  lth := len(rs)&#xA;&#xA;  // 简单的越界判断&#xA;  if begin &amp;lt; 0 {&#xA;    begin = 0&#xA;  }&#xA;  if begin &amp;gt;= lth {&#xA;    begin = lth&#xA;  }&#xA;  end := begin + length&#xA;  if end &amp;gt; lth {&#xA;    end = lth &#xA;  }&#xA;&#xA;  // 返回子串&#xA;  return string(rs[begin:end])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>投资自己</title>
      <link>http://www.wowzai.com/2014/invest-myself.html</link>
      <pubDate>2014-07-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##投资自己&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天老大找我谈了一下，大概说了下接下来的一些计划。接下来钢哥负责基金公司、基金子公司的需求，锋哥负责证券公司的需求，我负责内部需求，对外接口以及代码审核的工作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前由于人手的问题，我们的代码审核一直流于形式，是最容易丢的一块，接下来会当作一项任务来抓，我接下来将会用更多的精力放在代码上，这也是我希望的，我现在还不想太希望追着业务，赶着任务，我想把更多的精力放在代码上对于我无论是技术上还是业务上都是要好一些。接下来，我将会花上三个月左右的时间将我们的系统系统地梳理一遍，按照业务线一遍遍来，然后梳理成笔记，整理成文章，应该会放在这里，同时会将系统中涉及到的Oracle方面的一些知识，主要是SQL优化方面的知识也会整理一下放在这里，这样也算是对于我这两年工作的一个总结。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过呢，每个员工对于公司来说都是生产资料，公司希望每个生产资料都能发挥最大的作用，最好的情况是每个员工的方向和公司希望他走的方向是一致的，但是如果两者有冲突的时候，相信大部分情况下公司会选择公司利益最大化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，我想接下来，我将会将自己的精力更多地放在自己的事情上，主要是晚上的时间，golang、Android我来了！未来一定会更好的，加油！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>come on</title>
      <link>http://www.wowzai.com/2014/come-on.html</link>
      <pubDate>2014-07-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Come on&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一晃一个星期又过去了，周末在家啥也没干，尼玛，感觉这辈子是不是没得救了，卧槽。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过今天把房子租出去了，算是了了一件事，不用再为房子的事情烦心了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前安排好的计划看来又要拖延了，尼玛，接下来要更加地努力了，加油！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android Activity生命周期</title>
      <link>http://www.wowzai.com/2014/android-activity-lifecycle.html</link>
      <pubDate>2014-07-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Android Activity的生命周期&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要想谈谈Android Activity的生命周期，当然要从官方文档中的这个图说起：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;file:///D:/Android/adt-bundle-windows-x86_64-20140321/sdk/docs_backup0/images/activity_lifecycle.png&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实从这个图已经可以很清楚的看到一个Activity的整个生命周期，不过我们还是要做个实验。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;    &#xA;    public static final String TAG = &amp;quot;MainActivity&amp;quot;;&#xA;    &#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        &#xA;        System.out.println(&amp;quot;MainActivity onCreate&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onCreate&amp;quot;);&#xA;        &#xA;&#xA;        if (savedInstanceState == null) {&#xA;            getSupportFragmentManager().beginTransaction()&#xA;                    .add(R.id.container, new PlaceholderFragment())&#xA;                    .commit();&#xA;        }&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onStart() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onStart();&#xA;        System.out.println(&amp;quot;MainActivity onStart&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onStart&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onResume() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onResume();&#xA;        System.out.println(&amp;quot;MainActivity onResume&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onResume&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onPause() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onPause();&#xA;        System.out.println(&amp;quot;MainActivity onPause&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onPause&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onStop() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onStop();&#xA;        System.out.println(&amp;quot;MainActivity onStop&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onStop&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onRestart() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onRestart();&#xA;        System.out.println(&amp;quot;MainActivity onRestart&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onRestart&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onDestroy();&#xA;        System.out.println(&amp;quot;MainActivity onDestory&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onDestory&amp;quot;);&#xA;    }  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我这里不知道怎么回事，LogCat无法打印日期，这个问题回头再查，我只好用Debug模式跟进去看看这几个函数执行的先后顺序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先启动时，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onCreate&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此，这里前台已经可以展示内容，此时按下Home键，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;重新点开应用程序，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此前台可以看到展示内容，此时按下Back键，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onDestory&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从这个过程可以看到在OnResume和OnPause之间Activity是可见的，官方文档指出如果我们有需要永久保存的内容，我们最好是在OnPause()中实现，同时Back键是会Destory对应的Activity的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当有两个Activity时，其中一个Activity是由另一个Activity驱动打开的，例如一个是MainActivity，界面中有一个按钮,点击这个按钮之后会启动另一个Activity，例如叫OtherActivity，此时启动主程序首先进入的是MainActivity，调用顺序如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时可以看到MainActivity中的内容，可以看到MainActivity中有一个Click按钮，点击这个按钮会启动另一个Activity&amp;ndash;OtherActivity。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;点击Click按钮，MainActivity会先暂停，调用：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后启动OtherActivity：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onCreate&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候OtherActivity已经展现出来，接下来会将MainActivity停止掉，调用：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候再点击Back键，OtherActivity会先暂停，然后MainActivity会重启：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时返回到MainActivity的界面，同时OtherActivity会停止并销毁：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onDestory&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果在OtherActivity界面展现的时候，不点击Back而是点击Home键，&#xA;调用顺序将是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从桌面点击程序图标启动程序，此时会OtherActivity会重启，回到按Home键之前的状态：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>net.http如何提供http服务的大致实现</title>
      <link>http://www.wowzai.com/2014/http-in-golang.html</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天粗略的看了一下net.http的Server端的实现，总体上算是了解其大致的实现。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;golang建立一个web server&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;用golang建立一个web server是一件非常容易的一件事，在&lt;a href=&#34;http://golang.org/doc/effective_go.html#web_server&#34;&gt;Effective_go&lt;/a&gt;中就有个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;flag&amp;quot;&#xA;    &amp;quot;html/template&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;var addr = flag.String(&amp;quot;addr&amp;quot;, &amp;quot;:1718&amp;quot;, &amp;quot;http service address&amp;quot;) // Q=17, R=18&#xA;&#xA;var templ = template.Must(template.New(&amp;quot;qr&amp;quot;).Parse(templateStr))&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    http.Handle(&amp;quot;/&amp;quot;, http.HandlerFunc(QR))&#xA;    err := http.ListenAndServe(*addr, nil)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;ListenAndServe:&amp;quot;, err)&#xA;    }&#xA;}&#xA;&#xA;func QR(w http.ResponseWriter, req *http.Request) {&#xA;    templ.Execute(w, req.FormValue(&amp;quot;s&amp;quot;))&#xA;}&#xA;&#xA;const templateStr = `&#xA;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;&amp;lt;title&amp;gt;QR Link Generator&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&#xA;&amp;lt;img src=&amp;quot;http://chart.apis.google.com/chart?chs=300x300&amp;amp;cht=qr&amp;amp;choe=UTF-8&amp;amp;chl=map[site:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] data:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] layouts:map[default:map[_content:0xc084060c60] page:map[layout:default _content:0xc084060cf0] post:map[layout:default _content:0xc084060db0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084060870 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040960 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040ae0 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:wowzai的账簿 _content:0xc084040d20 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040f00 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084060570 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\2014.08.Plan.md:map[date:2014-08-05 layout:post title:2014.08计划 _content:0xc0840840c0 permalink:/2014/plan-of-2014-08.html categories:[Blog] tags:[plan] id:posts\2014.08.Plan.md _date:2014-08-05 00:00:00 +0000 UTC url:/2014/plan-of-2014-08.html] posts\Android Activity生命周期.md:map[date:2014-07-16 layout:post permalink:/2014/android-activity-lifecycle.html tags:[Android Activity] _content:0xc0840845d0 _date:2014-07-16 00:00:00 +0000 UTC url:/2014/android-activity-lifecycle.html title:Android Activity生命周期 categories:[Blog] id:posts\Android Activity生命周期.md] posts\Come On.md:map[title:come on categories:[Blog] id:posts\Come On.md url:/2014/come-on.html date:2014-07-20 layout:post permalink:/2014/come-on.html tags:[pieces] _content:0xc084084b40 _date:2014-07-20 00:00:00 +0000 UTC] posts\golang中获取中文字符串的子串字符位置及截取子串.md:map[date:2014-08-04 layout:post title:golang中获取中文字符串的子串字符位置及截取子串 permalink:/2014/chinese-string-in-golang.html tags:[golang] _content:0xc084040d80 id:posts\golang中获取中文字符串的子串字符位置及截取子串.md categories:[Blog] _date:2014-08-04 00:00:00 +0000 UTC url:/2014/chinese-string-in-golang.html] posts\自我git教程.md:map[layout:post categories:[Blog] _content:0xc0840841e0 id:posts\自我git教程.md url:/2014/my-git-manual.html date:2014-06-30 title:git自我教程 permalink:/2014/my-git-manual.html tags:[git 教程] _date:2014-06-30 00:00:00 +0000 UTC] posts\2014.09.Plan.md:map[date:2014-09-03 title:2014.09计划 permalink:/2014/plan-of-2014-09.html categories:[Blog] id:posts\2014.09.Plan.md _date:2014-09-03 00:00:00 +0000 UTC url:/2014/plan-of-2014-09.html layout:post tags:[plan] _content:0xc0840843c0] posts\Invest myself.md:map[date:2014-07-21 layout:post title:投资自己 permalink:/2014/invest-myself.html tags:[life] _content:0xc084084de0 _date:2014-07-21 00:00:00 +0000 UTC url:/2014/invest-myself.html categories:[Blog] id:posts\Invest myself.md] posts\golang中defer执行位置.md:map[layout:post title:golang中defer的执行位置 permalink:/2014/defer-in-golang.html categories:[Blog] _content:0xc084040b70 _date:2014-07-07 00:00:00 +0000 UTC date:2014-07-07 tags:[golang] id:posts\golang中defer执行位置.md url:/2014/defer-in-golang.html] posts\为什么那么穷还要去旅行.md:map[permalink:/2014/travel-really.html tags:[思考 旅行] _content:0xc0840ac2d0 url:/2014/travel-really.html date:2014-06-30 layout:post title:那么穷为什么还要去旅行 categories:[Blog] id:posts\为什么那么穷还要去旅行.md _date:2014-06-30 00:00:00 +0000 UTC] posts\Array和Slice.md:map[date:2014-07-09 _content:0xc0840847e0 url:/2014/array-and-slice-in-golang.html layout:post title:Array和Slice permalink:/2014/array-and-slice-in-golang.html categories:[Blog] tags:[golang] id:posts\Array和Slice.md _date:2014-07-09 00:00:00 +0000 UTC] posts\Method Value和Method Expression.md:map[layout:post permalink:/2014/method-value-vs-method-expression-in-golang.html id:posts\Method Value和Method Expression.md date:2014-07-08 title:Method Value和Method Expression categories:[Blog] tags:[golang] _content:0xc084084fc0 _date:2014-07-08 00:00:00 +0000 UTC url:/2014/method-value-vs-method-expression-in-golang.html] posts\Oracle中的执行计划.md:map[layout:post permalink:/2014/oracle-explain-plan-1.html id:posts\Oracle中的执行计划.md _date:2014-06-27 00:00:00 +0000 UTC url:/2014/oracle-explain-plan-1.html date:2014-06-27 title:Oracle中的执行计划 categories:[Blog] tags:[Oracle Explain plan] _content:0xc084084330] posts\Windows下查看端口和进程绑定.md:map[permalink:/2014/Windows下查看端口和进程绑定.html tags:[windows] _content:0xc084084660 id:posts\Windows下查看端口和进程绑定.md date:2014-06-26 layout:post title:Windows下查看端口和进程绑定 categories:[Blog] _date:2014-06-26 00:00:00 +0000 UTC url:/2014/Windows下查看端口和进程绑定.html] posts\first-blog.md:map[date:2014-05-15 layout:post title:我的第一篇Blog categories:[Blog] _date:2014-05-15 00:00:00 +0000 UTC url:/2014/new-born.html permalink:/2014/new-born.html tags:[new born] _content:0xc0840606c0 id:posts\first-blog.md] posts\买房.md:map[layout:post permalink:/2014/buy-house-1.html categories:[Blog] url:/2014/buy-house-1.html date:2014-08-10 title:买房1 tags:[plan] _content:0xc0840ac630 id:posts\买房.md _date:2014-08-10 00:00:00 +0000 UTC] posts\买房2.md:map[id:posts\买房2.md _date:2014-08-26 00:00:00 +0000 UTC url:/2014/buy-house-2.html date:2014-08-26 layout:post title:买房2 permalink:/2014/buy-house-2.html categories:[Blog] tags:[plan] _content:0xc0840ac990] posts\年轻真好.md:map[title:年轻真好 categories:[Blog] date:2014-09-08 layout:post permalink:/2014/young.html tags:[plan] _content:0xc0840aced0 id:posts\年轻真好.md _date:2014-09-08 00:00:00 +0000 UTC url:/2014/young.html] posts\golang的net.http的简单分析1.md:map[date:2014-07-10 layout:post permalink:/2014/http-in-golang.html tags:[golang] _content:0xc0840ac000 title:net.http如何提供http服务的大致实现 categories:[Blog] id:posts\golang的net.http的简单分析1.md _date:2014-07-10 00:00:00 +0000 UTC url:/2014/http-in-golang.html] posts\关于最近.md:map[date:2014-06-28 _content:0xc0840acc90 _date:2014-06-28 00:00:00 +0000 UTC url:/2014/2014-my-life-06.html layout:post title:关于最近 permalink:/2014/2014-my-life-06.html categories:[Blog] tags:[my life work] id:posts\关于最近.md]] tags:map[plan:0xc08406fa00 golang:0xc08406fc40 git:0xc08406fc80 Explain plan:0xc08406ffc0 Android:0xc08406fac0 life:0xc08406fd40 思考:0xc08406fe00 旅行:0xc08406fe40 Activity:0xc08406fb00 Oracle:0xc08406ff80 my life:0xc084006300 work:0xc084006380 pieces:0xc08406fbc0 教程:0xc08406fcc0 windows:0xc084006180 new born:0xc084006200] categories:map[Blog:0xc08406fa80] chronological:[posts\年轻真好.md posts\2014.09.Plan.md posts\买房2.md posts\买房.md posts\2014.08.Plan.md posts\golang中获取中文字符串的子串字符位置及截取子串.md posts\Invest myself.md posts\Come On.md posts\Android Activity生命周期.md posts\golang的net.http的简单分析1.md posts\Array和Slice.md posts\Method Value和Method Expression.md posts\golang中defer执行位置.md posts\自我git教程.md posts\为什么那么穷还要去旅行.md posts\关于最近.md posts\Oracle中的执行计划.md posts\Windows下查看端口和进程绑定.md posts\first-blog.md] collated:[0xc0840843f0]]]]&amp;quot; /&amp;gt;&#xA;&amp;lt;br&amp;gt;&#xA;map[site:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] data:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] layouts:map[default:map[_content:0xc084060c60] page:map[layout:default _content:0xc084060cf0] post:map[layout:default _content:0xc084060db0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084060870 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040960 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040ae0 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:wowzai的账簿 _content:0xc084040d20 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084040f00 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084060570 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\2014.09.Plan.md:map[date:2014-09-03 title:2014.09计划 permalink:/2014/plan-of-2014-09.html categories:[Blog] id:posts\2014.09.Plan.md _date:2014-09-03 00:00:00 +0000 UTC url:/2014/plan-of-2014-09.html layout:post tags:[plan] _content:0xc0840843c0] posts\Invest myself.md:map[categories:[Blog] id:posts\Invest myself.md date:2014-07-21 layout:post title:投资自己 permalink:/2014/invest-myself.html tags:[life] _content:0xc084084de0 _date:2014-07-21 00:00:00 +0000 UTC url:/2014/invest-myself.html] posts\golang中defer执行位置.md:map[date:2014-07-07 tags:[golang] id:posts\golang中defer执行位置.md url:/2014/defer-in-golang.html layout:post title:golang中defer的执行位置 permalink:/2014/defer-in-golang.html categories:[Blog] _content:0xc084040b70 _date:2014-07-07 00:00:00 +0000 UTC] posts\为什么那么穷还要去旅行.md:map[date:2014-06-30 layout:post title:那么穷为什么还要去旅行 categories:[Blog] id:posts\为什么那么穷还要去旅行.md _date:2014-06-30 00:00:00 +0000 UTC permalink:/2014/travel-really.html tags:[思考 旅行] _content:0xc0840ac2d0 url:/2014/travel-really.html] posts\Array和Slice.md:map[layout:post title:Array和Slice permalink:/2014/array-and-slice-in-golang.html categories:[Blog] tags:[golang] id:posts\Array和Slice.md _date:2014-07-09 00:00:00 +0000 UTC date:2014-07-09 _content:0xc0840847e0 url:/2014/array-and-slice-in-golang.html] posts\Method Value和Method Expression.md:map[date:2014-07-08 title:Method Value和Method Expression categories:[Blog] tags:[golang] _content:0xc084084fc0 _date:2014-07-08 00:00:00 +0000 UTC url:/2014/method-value-vs-method-expression-in-golang.html layout:post permalink:/2014/method-value-vs-method-expression-in-golang.html id:posts\Method Value和Method Expression.md] posts\Oracle中的执行计划.md:map[date:2014-06-27 title:Oracle中的执行计划 categories:[Blog] tags:[Oracle Explain plan] _content:0xc084084330 layout:post permalink:/2014/oracle-explain-plan-1.html id:posts\Oracle中的执行计划.md _date:2014-06-27 00:00:00 +0000 UTC url:/2014/oracle-explain-plan-1.html] posts\Windows下查看端口和进程绑定.md:map[date:2014-06-26 layout:post title:Windows下查看端口和进程绑定 categories:[Blog] _date:2014-06-26 00:00:00 +0000 UTC url:/2014/Windows下查看端口和进程绑定.html permalink:/2014/Windows下查看端口和进程绑定.html tags:[windows] _content:0xc084084660 id:posts\Windows下查看端口和进程绑定.md] posts\first-blog.md:map[date:2014-05-15 layout:post title:我的第一篇Blog categories:[Blog] _date:2014-05-15 00:00:00 +0000 UTC url:/2014/new-born.html permalink:/2014/new-born.html tags:[new born] _content:0xc0840606c0 id:posts\first-blog.md] posts\买房.md:map[layout:post permalink:/2014/buy-house-1.html categories:[Blog] url:/2014/buy-house-1.html date:2014-08-10 title:买房1 tags:[plan] _content:0xc0840ac630 id:posts\买房.md _date:2014-08-10 00:00:00 +0000 UTC] posts\买房2.md:map[date:2014-08-26 layout:post title:买房2 permalink:/2014/buy-house-2.html categories:[Blog] tags:[plan] _content:0xc0840ac990 id:posts\买房2.md _date:2014-08-26 00:00:00 +0000 UTC url:/2014/buy-house-2.html] posts\年轻真好.md:map[title:年轻真好 categories:[Blog] date:2014-09-08 layout:post permalink:/2014/young.html tags:[plan] _content:0xc0840aced0 id:posts\年轻真好.md _date:2014-09-08 00:00:00 +0000 UTC url:/2014/young.html] posts\golang的net.http的简单分析1.md:map[title:net.http如何提供http服务的大致实现 categories:[Blog] id:posts\golang的net.http的简单分析1.md _date:2014-07-10 00:00:00 +0000 UTC url:/2014/http-in-golang.html date:2014-07-10 layout:post permalink:/2014/http-in-golang.html tags:[golang] _content:0xc0840ac000] posts\关于最近.md:map[date:2014-06-28 _content:0xc0840acc90 _date:2014-06-28 00:00:00 +0000 UTC url:/2014/2014-my-life-06.html layout:post title:关于最近 permalink:/2014/2014-my-life-06.html categories:[Blog] tags:[my life work] id:posts\关于最近.md] posts\2014.08.Plan.md:map[permalink:/2014/plan-of-2014-08.html categories:[Blog] tags:[plan] id:posts\2014.08.Plan.md _date:2014-08-05 00:00:00 +0000 UTC url:/2014/plan-of-2014-08.html date:2014-08-05 layout:post title:2014.08计划 _content:0xc0840840c0] posts\Android Activity生命周期.md:map[date:2014-07-16 layout:post permalink:/2014/android-activity-lifecycle.html tags:[Android Activity] _content:0xc0840845d0 _date:2014-07-16 00:00:00 +0000 UTC url:/2014/android-activity-lifecycle.html title:Android Activity生命周期 categories:[Blog] id:posts\Android Activity生命周期.md] posts\Come On.md:map[title:come on categories:[Blog] id:posts\Come On.md url:/2014/come-on.html date:2014-07-20 layout:post permalink:/2014/come-on.html tags:[pieces] _content:0xc084084b40 _date:2014-07-20 00:00:00 +0000 UTC] posts\golang中获取中文字符串的子串字符位置及截取子串.md:map[categories:[Blog] _date:2014-08-04 00:00:00 +0000 UTC url:/2014/chinese-string-in-golang.html date:2014-08-04 layout:post title:golang中获取中文字符串的子串字符位置及截取子串 permalink:/2014/chinese-string-in-golang.html tags:[golang] _content:0xc084040d80 id:posts\golang中获取中文字符串的子串字符位置及截取子串.md] posts\自我git教程.md:map[date:2014-06-30 title:git自我教程 permalink:/2014/my-git-manual.html tags:[git 教程] _date:2014-06-30 00:00:00 +0000 UTC layout:post categories:[Blog] _content:0xc0840841e0 id:posts\自我git教程.md url:/2014/my-git-manual.html]] tags:map[pieces:0xc08406fbc0 教程:0xc08406fcc0 windows:0xc084006180 new born:0xc084006200 plan:0xc08406fa00 golang:0xc08406fc40 git:0xc08406fc80 Explain plan:0xc08406ffc0 Android:0xc08406fac0 life:0xc08406fd40 思考:0xc08406fe00 旅行:0xc08406fe40 Activity:0xc08406fb00 Oracle:0xc08406ff80 my life:0xc084006300 work:0xc084006380] categories:map[Blog:0xc08406fa80] chronological:[posts\年轻真好.md posts\2014.09.Plan.md posts\买房2.md posts\买房.md posts\2014.08.Plan.md posts\golang中获取中文字符串的子串字符位置及截取子串.md posts\Invest myself.md posts\Come On.md posts\Android Activity生命周期.md posts\golang的net.http的简单分析1.md posts\Array和Slice.md posts\Method Value和Method Expression.md posts\golang中defer执行位置.md posts\自我git教程.md posts\为什么那么穷还要去旅行.md posts\关于最近.md posts\Oracle中的执行计划.md posts\Windows下查看端口和进程绑定.md posts\first-blog.md] collated:[0xc0840843f0]]]]&#xA;&amp;lt;br&amp;gt;&#xA;&amp;lt;br&amp;gt;&#xA;&#xA;&amp;lt;form action=&amp;quot;/&amp;quot; name=f method=&amp;quot;GET&amp;quot;&amp;gt;&amp;lt;input maxLength=1024 size=70&#xA;name=s value=&amp;quot;&amp;quot; title=&amp;quot;Text to QR Encode&amp;quot;&amp;gt;&amp;lt;input type=submit&#xA;value=&amp;quot;Show QR&amp;quot; name=qr&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;因为net.http提供了web server的功能，这样可以很简单的建立一个页面供用户来访问，上面的例子中templateStr就是页面的html代码，可以用html/template的API来实现动态效果，具体可以查看&lt;a href=&#34;http://golang.org/pkg/html/template/&#34;&gt;template&lt;/a&gt;的API，然后有个HandlerFunc类型的函数，来处理response和request，这样就可以提供web服务了，真的很简单！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Web Server的内部实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;仅仅对于使用，通过上面的例子再加上API的查询，相信就可以编写应用了，但是对于我，我还想了解一下其内部的具体实现，一来熟悉golang，从代码中学习，二来通过实践增加对于HTTP协议的了解，三来增强自己造轮子的能力，哈哈，真正的是一矢三鸟啊，想想就兴奋。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，通过上面的例子，可以知道这里主要是使用了两个函数完成，第一个http.Handle,第二个是http.ListenAndServe。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中，http.Handle接受两个参数，第一个是地址（可以看成于根的相对地址），用来路由页面的，第二个是一个接受ResponseWriter和*Request的函数。例子中函数QR就是一个，QR拿到Response和Request后可以进行一些处理，然后将结果返回给客户端。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;http.ListenAndServe是将会监听http服务并提供服务，那么他是如何工作的呢？首先创建一个Server，Server顾名思义就是服务端服务的提供者啦，它的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A Server defines parameters for running an HTTP server.&#xA;type Server struct {&#xA;    Addr   string// TCP address to listen on, &amp;quot;:http&amp;quot; if empty&#xA;    Handler Handler   // handler to invoke, http.DefaultServeMux if nil&#xA;    ReadTimeouttime.Duration // maximum duration before timing out read of the request&#xA;    WriteTimeout   time.Duration // maximum duration before timing out write of the response&#xA;    MaxHeaderBytes int   // maximum size of request headers, DefaultMaxHeaderBytes if 0&#xA;    TLSConfig  *tls.Config   // optional TLS config, used by ListenAndServeTLS&#xA;&#xA;    // TLSNextProto optionally specifies a function to take over&#xA;    // ownership of the provided TLS connection when an NPN&#xA;    // protocol upgrade has occurred.  The map key is the protocol&#xA;    // name negotiated. The Handler argument should be used to&#xA;    // handle HTTP requests and will initialize the Request&#39;s TLS&#xA;    // and RemoteAddr if not already set.  The connection is&#xA;    // automatically closed when the function returns.&#xA;    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接受传进去的Addr作为建立TCP监听的地址，Handler作为Server的Hander。&#xA;通过net.Listen方法获得一个TCP的Listener l,在调用server的Serve方法，将l传进去，server在提供Serve的时候首先会根据传进来的listener获得一个conn，记住这个conn可是web server的基础哦，客户端和服务端的一切通信都是建立在它的基础之上，有个这个conn之后，才有可能提供web服务。server在拿到这个conn之后，会进行一些错误处理，然后对这个net.conn进行一层封装获得一个http connection，conn定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A conn represents the server side of an HTTP connection.&#xA;    type conn struct {&#xA;        remoteAddr string   // network address of remote side&#xA;        server *Server      // the Server on which the connection arrived&#xA;        rwcnet.Conn         // i/o connection&#xA;        sr liveSwitchReader // where the LimitReader reads from; usually the rwc&#xA;        lr *io.LimitedReader// io.LimitReader(sr)&#xA;        buf*bufio.ReadWriter// buffered(lr,rwc), reading from bufio-&amp;gt;limitReader-&amp;gt;sr-&amp;gt;rwc&#xA;        bufswr *switchReader// the *switchReader io.Reader source of buf&#xA;        bufsww *switchWriter// the *switchWriter io.Writer dest of buf&#xA;        tlsState   *tls.ConnectionState // or nil when not using TLS&#xA;&#xA;        mu   sync.Mutex     // guards the following&#xA;        clientGone   bool   // if client has disconnected mid-request&#xA;        closeNotifyc chan bool  // made lazily&#xA;        hijackedvbool       // connection has been hijacked by handler&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;newConn会将net.Conn进行封装，在net.Conn执行封装一些BufferReader,BufferWriter，BufferReadWriter，switchReader等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有了这个conn之后，server就会调用它的serve方法提供服务了，serve方法中，会调用readRquest()获得一个response，这个response并不是http.Response，而是server端的response，与http.Response封装是不同嘀，它实现了ResponseWriter接口，response中有个成员是一个http.Request,有了ResponseWriter和Request之后，就可以调用用户自己实现的ServeHTTP处理逻辑处理数据并将结果返回给数据。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Array和Slice</title>
      <link>http://www.wowzai.com/2014/array-and-slice-in-golang.html</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;Array&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Array可以看作一个有长度的变量，每个单元都可以存放一个元素，例如：&lt;br /&gt;&#xA;    var buffer [100]int&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在内存中buffer类似如下：&lt;br /&gt;&#xA;   &lt;code&gt;buffer: int int int ... 100 times ... int int int&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Array中的长度也是类型的一部分，例如[200]int和[100]int是不同类型的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;testArray(arr [100]int) {&#xA;  // ...&#xA;}&#xA;&#xA;var a1 [100]int&#xA;var a2 [200]int&#xA;&#xA;testArray(a1)  // OK&#xA;testArray(a2)  // Wrong&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Array可以用来表示矩阵，但是通常是作为slice的存储基础&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Slice Header&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Slice可以看作是Array的部分片段，而不是Array（A Slice is not an an array,a slice is piece of an array）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := array[10:20]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice也可以对slice进行“切片”：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s2 := slice[5:10]  //新定义一个变量s2，是对slice片段的描述&#xA;slice := slice[5:10]  //对自己切片并将变量付给自身&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以将Slice看成一个包含长度和起始地址的数据结构：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type sliceHeader struct {&#xA;  Length    int&#xA;  ZeroElement *int  //不一定是*int，元素是什么类型就是什么类型的指针&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;例如上面的slice变量可以看成如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := sliceHeader {&#xA;  Length: 10,&#xA;  ZeroElement: &amp;amp;array[10],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Slice作为函数参数传递&#xA;slice是一个包含长度和一个指针的结构体的值，而不是一个指向一个结构体的指针，函数参数中的slice在传进去的时候是一个struct值的复制值，修改slice中的元素值就是修改其所持有Array的元素值，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func AddSlice(slice []int) {  &#xA;  for i := range slice {  &#xA;    slice[i]++  &#xA;  }  &#xA;} &#xA;func main() {  &#xA;  slice := []int{1,2,3,4,5,6,7,8,9,10}  &#xA;  fmt.Println(&amp;quot;before:&amp;quot;,slice)  &#xA;  AddSlice(slice)  &#xA;  fmt.Println(&amp;quot;after:&amp;quot;,slice) &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pirint:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: [1,2,3,4,5,6,7,8,9,10]&#xA;after: [2,3,4,5,6,7,8,9,10,11]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数传递进去时候slice只是一个复制值，可以通过如下例子看出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func SubSlice(slice []int) []int {&#xA;  slice := slice[0:len(slice)-1]&#xA;  return slice&#xA;}&#xA;&#xA;func main() {&#xA;  slice := []int{1,2,3,4,5,6,7,8,9,10}  &#xA;  fmt.Println(&amp;quot;before: len(slice) =&amp;quot;,slice)  &#xA;  newSlice := SubSlice(slice)  &#xA;  fmt.Println(&amp;quot;after: len(slice) =&amp;quot;,slice)&#xA;  fmt.Println(&amp;quot;after: len(newSlice) =&amp;quot;,newSlice) &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: len(slice) = 10&#xA;after: len(slice) = 10&#xA;after: len(newSlice) = 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;指向Slice的指针&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果想修改slice header的内容，可以传递一个指向slice的指针，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func PtrSubSlice(slicePtr *[]int) {&#xA;  newSlice := *slicePtr&#xA;  *slicePtr = newSlice[0:len(newSlice)-1]&#xA;}&#xA;func main() {&#xA;  fmt.Println(&amp;quot;before: len(slice) =&amp;quot;, len(slice))&#xA;  PtrSubSlice(&amp;amp;slice)&#xA;  fmt.Println(&amp;quot;after: len(slice) =&amp;quot;, len(slice))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: len(slice) = 10&#xA;after: len(slice) = 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;作为方法的接收者，可以修改这个slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type path []byte&#xA;&#xA;func (p *path) TruncateAtFinalSlash() {&#xA;  i := bytes.LastIndex(*p,[]byte(&amp;quot;/&amp;quot;))&#xA;  if i &amp;gt;= 0 {&#xA;    *p = (*p)[0:i]&#xA;  }&#xA;}&#xA;&#xA;//ASCII letters to Upper&#xA;func (p path) ToUpper() {&#xA;  for i,b := rang p {&#xA;    if &#39;a&#39; &amp;lt;= b &amp;amp;&amp;amp; b &amp;lt;= &#39;z&#39; {&#xA;      p[i] = b + &#39;A&#39; - &#39;a&#39;&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;func main() {&#xA;  pathName := path(&amp;quot;/usr/bin/tso&amp;quot;)&#xA;  pathName.TruncateAtFinalSlash()&#xA;  fmt.Printf(&amp;quot;%s\n&amp;quot;,pathName)&#xA;  pathName.ToUpper()&#xA;  fmt.Printf(&amp;quot;%s\n&amp;quot;,pathName)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/usr/bin&#xA;/USR/BIN&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###容量(Capacity)&#xA;如何扩展slice的长度呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Extend(slice []int, element int) []int {&#xA;  n := len(slice)&#xA;  slice = slice[0:n+1]&#xA;  slice[n] = element&#xA;  return slice  //why return the modified slice?&#xA;}&#xA;&#xA;func main() {&#xA;  var array [10]int&#xA;  slice := array[0:0] // slice:[]&#xA;  for i:=0; i&amp;lt;20; i++ {&#xA;    slice = Extend(slice,i)&#xA;    fmt.Println(slice)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里运行的时候会报错，只会打印出前面10个数字，因为超过10的话已经超过了slice底层的array的长度，所以slice header还包含它的容量，表示其能表示的最大长度：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type sliceHeader struct {&#xA;  Length int&#xA;  Capacity int&#xA;  ZeroElement *byte&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当执行了slice := array[0:0]的时候，slice header如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := sliceHeader {&#xA;  Length: 0,&#xA;  Capacity: 10,&#xA;  ZeroElement: &amp;amp;array[0],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以通过内置的cap函数获得slice的容量：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if cap(slice) == len(slice) {&#xA;  fmt.Println(&amp;quot;slice is full&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Make&#xA;上面的例子中我们可以看到在要扩张slice的时候，这个时候我们就可以用内置的make函数来扩展我们的slice:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10, 15)&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;len:10, cap:15&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以让我们的slice扩展两倍：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10, 15)&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;newSlice := make([]int, len(slice), 2*cap(slice))&#xA;for i := range slice {&#xA;  newSlice[i] slice[i]&#xA;}&#xA;slice = newSlice&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pirnt:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;len:10, cap:15&#xA;len:10, cap:30&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;make也可以只传递两个值，这样它的len和cap就是一样的了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice的len和cap都是10&lt;/p&gt;&#xA;&#xA;&lt;p&gt;make的时候是创建一个新的数组作为slice的存储，下面例子可以看出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s1 := make([]int,5,10)&#xA;s2 := make([]int,len(s2),2*cap(s1))&#xA;fmt.Printf(&amp;quot;s1.addr:%v,s2.addr:%v\n&amp;quot;,&amp;amp;s2[1],&amp;amp;s8[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s2.addr:0x11701540,s8.addr:0x1170155c&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Copy&#xA;在扩展的时候，我们可能需要复制一个slice到另一个slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Insert(slice []int, index,value int) []int {&#xA;  slice := slice[0:len(slice)+1]&#xA;  copy(slice[index+1:],slice[index:])&#xA;  slice[index] = value&#xA;  return slice&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice[i:]和slice[i:len(slice)]一样，slice[:]和slice一样&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Append&lt;/p&gt;&#xA;&#xA;&lt;p&gt;自己创建一个Append来扩展slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Append(slice []int, elements ...int) []int {&#xA;  n := len(slice)&#xA;  total := n + len(elements)  //elements看以看作是一个slice,可以其计算长度&#xA;  if total &amp;gt; cap(slice) {&#xA;    newSlice := make([]int,total,total*3/2)&#xA;copy(newSlice,slice)&#xA;    slice = newSlice &#xA;  }&#xA;  slcie = slice[:total]&#xA;  copy(slice[n:],elements)&#xA;  return slice&#xA;}&#xA;&#xA;func main() {&#xA;  s1 := []int{0,1,2,3,4}&#xA;  s2 := []int{5,6,7}&#xA;  fmt.Println(s1)&#xA;  s1 = Append(s1,s2...)  //&#39;...&#39;是必须的&#xA;  fmt.Println(s1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[0,1,2,3,4]&#xA;[0,1,2,3,4,5,6,7]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###内建的append&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上面是自己写的一个Append的函数，其实go中实现了一个内建的append，而且这个append对于任何类型的slice都可以append：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Create a couple of starter slices.&#xA;slice = []int{1, 2, 3}&#xA;slice2 := []int{55, 66, 77}&#xA;fmt.Println(&amp;quot;Start slice: &amp;quot;, slice)&#xA;fmt.Println(&amp;quot;Start slice2:&amp;quot;, slice2)&#xA;fmt.Printf(&amp;quot;slice[0]:%p,slice2[0]:%p\n&amp;quot;,&amp;amp;slice[0],&amp;amp;slice2[0])&#xA;&#xA;// Add an item to a slice.&#xA;slice = append(slice, 4)&#xA;fmt.Println(&amp;quot;Add one item:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&#xA;// Add one slice to another.&#xA;slice = append(slice, slice2...)&#xA;fmt.Println(&amp;quot;Add one slice:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&#xA;// Make a copy of a slice (of int).&#xA;slice3 := append([]int(nil), slice...)&#xA;fmt.Println(&amp;quot;Copy a slice:&amp;quot;, slice3)&#xA;fmt.Printf(&amp;quot;slice3[0]:%p\n&amp;quot;,&amp;amp;slice3[0])&#xA;&#xA;// Copy a slice to the end of itself.&#xA;fmt.Println(&amp;quot;Before append to self:&amp;quot;, slice)&#xA;slice = append(slice, slice...)&#xA;fmt.Println(&amp;quot;After append to self:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过地址打印，我们会看到每次append之后返回的slice的地址都是不一样的，所以内建的append是会重新生成一个底层的array来持有数据的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###什么是nil&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go中如果一个slice是nil的，那么他的长度和容量都是0，并且它的起始地址是nil的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sliceHeader {&#xA;  Length: 0,&#xA;  Capacity: 0,&#xA;  ZeroElement: nil,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sliceHeader{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;需要注意的是它的起始地址为nil，如果一个slice是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice = array[0:0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么这个slice不是nil的，因为它有起始地址，nil的slice是没有地方给它存储元素的并且是不可以增长，但是nil的slice是可以append的，因为append会重新分配空间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###字符串(Strings)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;字符串可以看作是一个只读的字节(bytes)slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slash := &#39;/usr/bin&#39;[0]  //value is &#39;/&#39;&#xA;usr := &#39;/usr/bin&#39;[0:4] //value is &#39;/usr&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们还可以直接将byte slice强制转换成字符串&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str := string(slice)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者反过来：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := []byte(str)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然，对于字符串还有很多，这只是一个简单的概述&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，我们了解了slice和array的基本结构，尤其是slice的实现原理，对于我们使用slice是非常有益的，尤其是内建的copy和append函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考资料：&lt;a href=&#34;http://blog.golang.org/go-slices-usage-and-internals&#34;&gt;http://blog.golang.org/go-slices-usage-and-internals&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Method Value和Method Expression</title>
      <link>http://www.wowzai.com/2014/method-value-vs-method-expression-in-golang.html</link>
      <pubDate>2014-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;根据调用者不同，方法分为两种表现形式：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;instance.method(args&amp;hellip;)  &lt;type&gt;.func(instance,args&amp;hellip;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中，前者为method value,后者为method expression。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两者的区别是method value绑定实例，method expression则须显示传参。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type User struct {&#xA;  id   int&#xA;  name string&#xA;}&#xA;&#xA;func (self *User) Test() {&#xA;  fmt.Printf(&amp;quot;%p, %v\n&amp;quot;,self,self)&#xA;}&#xA;&#xA;func main() {&#xA;  u := User{1,&amp;quot;Tom&amp;quot;}&#xA;  u.Test()&#xA;&#xA;  mValue := u.Test  //这里u是一个实例(instance)&#xA;  mValue()  //所以这里是method value，隐式传递receiver&#xA;&#xA;  mExpression := (*User).Test //这里*User是&amp;lt;type&amp;gt;&#xA;  mExpression(&amp;amp;u)//所以这里显示传递receiver&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;0x210030000,&amp;amp;{1 Tom}&#xA;0x210030000,&amp;amp;{1 Tom}&#xA;0x210030000,&amp;amp;{1 Tom}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;method value会复制receiver&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type User struct {&#xA;  id int&#xA;  name string&#xA;}&#xA;&#xA;func (self User) Test() {&#xA;  fmt.Println(self)&#xA;}&#xA;&#xA;func main() {&#xA;  u := User{1,&amp;quot;Tom&amp;quot;}&#xA;  mValue := u.Test  //立即复制 receiver,因为不是指针类型，不受后续修改影响&#xA;&#xA;  u.id,u.name = 2, &amp;quot;Jack&amp;quot;&#xA;  u.Test()&#xA;&#xA;  mValue()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{2 Jack}&#xA;{1 Tom}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>golang中defer的执行位置</title>
      <link>http://www.wowzai.com/2014/defer-in-golang.html</link>
      <pubDate>2014-07-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##golang中defer的执行位置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大家都知道golang的defer关键字，它可以在函数返回前执行一些操作，最常用的就是打开一个资源（例如一个文件、数据库连接等）时就用defer延迟关闭改资源，以免引起内存泄漏。例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func do() (ok bool) {&#xA;  file,_ := os.Open(&amp;quot;c:\a.txt&amp;quot;)&#xA;  defer file.Close()&#xA;  // doSomething&#xA;  return ok&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以在官方的文档中看到defer的执行顺序是逆序的，也就是先进后出的顺序：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; 5; i++ {&#xA;  defer fmt.Printf(&amp;quot;%d &amp;quot;, i)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打印结果是：4,3,2,1,0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么再看这个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func deferRet(x,y int) (z int){&#xA;  defer z += 100&#xA;  z = x + y&#xA;  return z + 50 // 执行顺序 z = z+50 -&amp;gt; (call defer)z = z+100 -&amp;gt; ret  &#xA;}&#xA;&#xA;func main() {&#xA;  i := deferRet(1,1)&#xA;  println(i)  // print 152&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我想这个例子已经能够让你明白defer的执行顺序了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>git自我教程</title>
      <link>http://www.wowzai.com/2014/my-git-manual.html</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;首先，需要说明的是这是写给自己看的，所以叫自我教程，这里只是记录我经常要用的一些命令，并且会持续更新，由于我最近刚刚开始使用git，所以很多东西还不懂的使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;初始化库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git init&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;增加文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git add &amp;lt;filename&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;提交文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;comment&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查看远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote -v &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;增加远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;eg:&#xA;&lt;code&gt;&#xA;git remote add wowzai git@github.com:wowzai/repo.git&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果发现远程库写错了，可以删除远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote remove &amp;lt;name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从远处库中拉取远程库到本地库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git pull remote-repo-name&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;暂时我常用的一些git命令就是这些，对于像合并、建立分支我暂时还没用到，所以这里先不记录，等用到了再来了解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;持续更新中&amp;hellip;&amp;gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>那么穷为什么还要去旅行</title>
      <link>http://www.wowzai.com/2014/travel-really.html</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;要么读书，要么旅行，身体和灵魂总有一个在路上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这句话也无从考证最原始的出处了，不过有一个叫刘屈艳扬(http://baike.baidu.com/view/10466274.htm?fr=aladdin#作者简介)写了一本这本书《要么读书，要么旅行，身体和灵魂总有一个在路上》(http://book.douban.com/subject/24264880/)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;《身体和灵魂.总有一个要在路上》&#xA;&lt;a href=&#34;http://book.douban.com/subject/10806089/&#34;&gt;http://book.douban.com/subject/10806089/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在我小时候，那里是农村，那时候还能直接从沟里挑水喝，那是个无山但是水清的地方，但是那时候大家都很穷。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>关于最近</title>
      <link>http://www.wowzai.com/2014/2014-my-life-06.html</link>
      <pubDate>2014-06-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近工作很忙，哦，不，是一直以来工作都是很忙，好像一直都没有喘气的机会，自己心里总是想着这次把手头上的事情做完了可以好好休息一小段时间，调整调整，但是好像一直都没有机会喘口气，就这样一直忙呀忙，但是好像又什么都没有忙出来，瞎忙啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;去年的这个时候，涛哥离职了，说实话挺触动我的，我就在想我哪一天会从这个办公室走出去，可能再也不会走回来。转眼一年的时间过去了，工作强度似乎不减反增，除了周五，几乎每天都加班。每天手上有很多事情。忙碌的工作，一件事情做的不好，心里都不好受，但是又不可避免，心里压力好大。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;繁忙的对我最大的影响是记忆力下降，脑子记不住事情了，最明显的是水杯总是忘了，要么忘了盛水，要么是盛水了忘了带回来，还有就是脑子跟不上，总是两眼发呆，脑子感觉是空的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;工作似乎陷入了一个恶性循环，事情越多&amp;ndash;&amp;gt;手忙脚乱&amp;ndash;&amp;gt;心理压力大&amp;ndash;&amp;gt;忙中出错&amp;ndash;&amp;gt;事情越多，好像没有时间来好好梳理梳理，有个周末，惰性加一些乱七八糟的事情两天很快就过去了。然后周一又重复上一周的工作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于工作占用了我的大部分时间，再加上自己的时间管理差，导致我自己的计划无法开展开来，生活变得有一点点糟糕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一年的时间很快，眼看着涛哥离开，一年内自己想学的东西基本上一样都没有学成，明年的现在，我又能达到期望中的我百分之多少呢，同时合同也将到期，我还会留在这里嘛？ 天知道。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;哎，就是发发牢骚，其实心里挺难过的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Oracle中的执行计划</title>
      <link>http://www.wowzai.com/2014/oracle-explain-plan-1.html</link>
      <pubDate>2014-06-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Oracle中的执行计划&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于工作的关系，最近准备系统的学习一下Oracle相关知识，尤其是优化方面的东西，因为工作中可能会碰到性能问题，所以需要准备学习一下这方面的知识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;讲到Oracle的性能优化，首先想到的就是Oracle中的优化器。众所周知，Oracle中的优化器有RBO和CBO，由于RBO机会没有什么实际用处，这里就不赘述。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CBO中用到的两个概念：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;集的势&lt;/strong&gt;&lt;br /&gt;&#xA;Cardinlity表示对目标SQL的某个具体执行步骤的执行结果所包含记录数的估算，如果是针对整个目标SQL，那么此时的Cardinality就表示对该SQL最终执行结果所包含记录数的估算。&#xA;一般情况下某个执行步骤对应的Cardinality的值越大，其所对应的成本值往往也就越大，这个执行步骤所在执行路径的总成本值也就会越大。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;可选择率&lt;/strong&gt;&lt;br /&gt;&#xA;Selectivity = 施加指定谓词条件后返回结果集的记录数/未施加任何谓词条件的原始结果集记录数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;补充：Cardinlity和Selectivity对于性能的影响&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;访问数据的方法&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;访问表的方法&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全表扫描： 从表所占用的第一区的第一块开始扫描，直到高水位。需要注意的是高水位并不会因为数据被delete了而降低，就像河中的水位线一样，即使退水了，留在岸上的水位线还在哪里，不会因此而降低（关于如何消除高水位，这又是另外一个问题了，后面再作讨论）。&lt;/li&gt;&#xA;&lt;li&gt;ROWID扫描：直接通过数据所在的ROWID定位并访问数据&lt;br /&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据用户输入的ROWID值去访问（较少）&lt;/li&gt;&#xA;&lt;li&gt;根据访问索引后的ROWID再回表访问对应的数据行记录（较多）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;访问索引的方法&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;索引唯一扫描：仅针对唯一索引的等值查找（=），即where条件中是唯一索引列的等值查询&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引范围扫描：唯一索引的范围查找（&amp;lt;、&amp;gt;、between等），非唯一索引where条件没有限制（不管是等值查询还是范围查询）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引全扫描：非空索引列的查询，查找是从最左边的叶子块的第一行，然后利用叶子块之间的双向指针链表，从左往右扫描索引块的索引行。因此索引全扫描是有序的，并且按照索引的键值列来排序，即走索引全扫描能达到排序的结果，同时避免对该索引键值列的真正排序操作。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引快速扫描：与索引全扫描相似，都适用于所有类型的B树索引（包括唯一性索引和非唯一性索引），扫描目标索引的所有叶子块的所有索引行。索引快速全扫描与索引全扫描有三点区别：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引快速全扫描只适用于CBO&lt;/li&gt;&#xA;&lt;li&gt;索引快速全扫描可以使用多块读，也可以并行执行&lt;/li&gt;&#xA;&lt;li&gt;索引快速全扫描执行结果不一定有序，因为此时是根据索引行所在的磁盘上的物理存储顺序扫描的，而不是根据索引行的逻辑顺序扫描的，所以扫描结果不一定有序（单个索引叶子块其物理顺序和逻辑顺序是一致的，但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序不一定在逻辑上有序）。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引跳跃式扫描：对于那些where条件中没有对索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标SQL，就像在扫描该索引时跳过了它的前导列，直接从该索引的非前导列开始扫描一样（世界并非如此）。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前导列的distinct值较少，非前导列的选择性好的情况。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Windows下查看端口和进程绑定</title>
      <link>http://www.wowzai.com/2014/Windows下查看端口和进程绑定.html</link>
      <pubDate>2014-06-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;windows下查看端口和进程绑定&#34; href=&#34;#windows下查看端口和进程绑定&#34;&gt;&lt;/a&gt;Windows下查看端口和进程绑定&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;最近准备开始学习Android开发，昨晚在用Eclipse开发，准备在模拟器上面跑程序的时候，报8700端口已经被绑定了，我很奇怪，心想难道是其他程序把8700端口给占用了？ 但是我还不知道如何查是哪个程序将8700端口占用了。于是上网查了一下如何查看端口和进程的绑定情况，这里做个记录，以备后忘，哈哈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.netstat -ano | findstr &amp;ldquo;8700&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TCP     127.0.0.1：8700      0.0.0.0：0       LISTENING       6988&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中最后一列的6988是对应进程的PID，然后再通过tasklist命令查找那个进程是6988&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.tasklist | findstr &amp;ldquo;6988&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;eclipse.exe     6988    Console         1       388,448K&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样通过简单的两个命令就能找出哪个程序将8700端口给占用了。这里，我可能不小心开了两个eclipse，导致第一个已经占用了8700端口，后面一个试图获得8700端口时就会报错。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇Blog</title>
      <link>http://www.wowzai.com/2014/new-born.html</link>
      <pubDate>2014-05-15 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;我的第一篇Blog&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;ndash;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我的第一篇blog,new born!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;加油吧，少年！&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>