<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>wowzai&#39;s blog</title>
    <link>http://www.wowzai.com</link>
    <pubDate>24 May 15 13:56 CST</pubDate>
    <item>
      <title>jQuery学习笔记1</title>
      <link>http://www.wowzai.com/2015/jQuery-notes-1.html</link>
      <pubDate>2015-05-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.ready事件，event.preventDefault()组织默认程序执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    &amp;lt;a href=&amp;quot;http://jquery.com/&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&#xA;    &amp;lt;script src=&amp;quot;scripts/jquery-1.11.2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script&amp;gt;&#xA;        $(document).ready(function() {&#xA;            $(&amp;quot;a&amp;quot;).click(function( event ) {&#xA;                alert( &amp;quot;As you can see, the link no longer took you to jquery.com&amp;quot; );&#xA;                event.preventDefault();&#xA;            });&#xA;       });&#xA;    &amp;lt;/script&amp;gt;&#xA;&#xA;    $( &amp;quot;a&amp;quot; ).addClass( &amp;quot;test&amp;quot; );&#xA;&#xA;    $( &amp;quot;a&amp;quot; ).removeClass( &amp;quot;test&amp;quot; );&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.回调&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无参数的：&lt;br /&gt;&#xA;&lt;code&gt;&#xA;$.get( &amp;quot;myhtmlpage.html&amp;quot;, myCallBack );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.get()完成之后会执行myCallBack()函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有参数的：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正确做法：&#xA;&lt;code&gt;&#xA;$.get( &amp;quot;myhtmlpage.html&amp;quot;, function() {&#xA;    myCallBack( param1, param2 );&#xA;});&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;错误做法：&#xA;&lt;code&gt;&#xA;$.get( &amp;quot;myhtmlpage.html&amp;quot;, myCallBack( param1, param2 ) );&#xA;&lt;/code&gt;&#xA;这种做法会立即执行myCallBack( param1, param2 )，把myCallBack( param1, param2 )的执行结果当作$.get()的第二个参数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;#$ vs $()&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$()：是命名空间$.fn中选择器，并且自动把选择的节点作为this传递给函数并返回，eg: $(&amp;ldquo;h1&amp;rdquo;).remove()&#xA;$：调用$命名空间中的实用方法，eg:$.trim(&amp;rdquo;  lots of extra whitespace  &amp;ldquo;) //return &amp;ldquo;lots of extra whitespace&amp;rdquo;&#xA;更多实用方法： &lt;a href=&#34;http://learn.jquery.com/using-jquery-core/utility-methods/&#34;&gt;文档1&lt;/a&gt;、&lt;a href=&#34;http://api.jquery.com/category/utilities/&#34;&gt;文档2&lt;/a&gt;&lt;br /&gt;&#xA;&lt;code&gt;&#xA;$( document ).ready()&#xA;&lt;/code&gt;&#xA;$(document).ready()只有在页面的Document Object Model (DOM)加载好了之后就可以执行，而&#xA;$( window ).load(function() { &amp;hellip; }) 只有在整个页面（包括图片、iframe）加载完成之后才可以执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;&amp;lt;script src=&amp;quot;scripts/jquery-1.11.2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    $( document ).ready(function() {&#xA;        console.log( &amp;quot;document loaded&amp;quot; );  //页面DOM加载完成即打印&#xA;    });&#xA;    $( window ).load(function() {&#xA;        console.log( &amp;quot;window loaded&amp;quot; );   //页面DOM加载完成即打印&#xA;    });&#xA;&amp;lt;/script&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&amp;lt;iframe src=&amp;quot;http://baidu.com&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;#Avoiding Conflicts with Other Libraries&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三种方法：&lt;br /&gt;&#xA;1.用一个新的命名，加载是必须放在别的库的后面：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;// Give $ back to prototype.js; create new alias to jQuery.&#xA;var $jq = jQuery.noConflict();&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.当作一个函数调用，加载是放在别的库之前：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Using the $ inside an immediately-invoked function expression. --&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;jQuery.noConflict();&#xA;&#xA;(function( $ ) {&#xA;// Your jQuery code here, using the $&#xA;})( jQuery );&#xA;&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3.当作函数参数传递，加载是放在别的库之前：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;jQuery(document).ready(function( $ ) {&#xA;// Your jQuery code here, using $ to refer to jQuery.&#xA;});&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者换成一种容易让人疑惑但是也是正确的写法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;jQuery(function($){&#xA;// Your jQuery code here, using the $&#xA;});&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;##Attributes&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.attr()方法及当作getter也当作setter，.attr()可以接受一个键及其对应的值，也可以接受一个包含一个或多个键值对的对象：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当作setter:&#xA;&lt;code&gt;&#xA;$( &amp;quot;a&amp;quot; ).attr( &amp;quot;href&amp;quot;, &amp;quot;allMyHrefsAreTheSameNow.html&amp;quot; );&#xA;$( &amp;quot;a&amp;quot; ).attr({&#xA;    title: &amp;quot;all titles are the same too!&amp;quot;,&#xA;    href: &amp;quot;somethingNew.html&amp;quot;&#xA;});&#xA;&lt;/code&gt;&#xA;当作getter:&#xA;&lt;code&gt;&#xA;$( &amp;quot;a&amp;quot; ).attr( &amp;quot;href&amp;quot; ); // Returns the href for the first a element in the document&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;#Selecting Elements&lt;/p&gt;&#xA;&#xA;&lt;p&gt;来自&lt;a href=&#34;http://learn.jquery.com/using-jquery-core/selecting-elements/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过ID获取：&#xA;&lt;code&gt;&#xA;$( &amp;quot;#myId&amp;quot; ); // Note IDs must be unique per page.&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过Class Name获取：&#xA;&lt;code&gt;&#xA;$( &amp;quot;.myClass&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过属性获取：&#xA;&lt;code&gt;&#xA;$( &amp;quot;input[name=&#39;first_name&#39;]&amp;quot; ); // Beware, this can be very slow in older browsers&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过复核CSS选择器：&#xA;$( &amp;ldquo;#contents ul.people li&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###伪选择器：&#xA;&lt;code&gt;&#xA;$( &amp;quot;a.external:first&amp;quot; );&#xA;$( &amp;quot;tr:odd&amp;quot; );&#xA;// Select all input-like elements in a form (more on this below).&#xA;$( &amp;quot;#myForm :input&amp;quot; );&#xA;$( &amp;quot;div:visible&amp;quot; );&#xA;// All except the first three divs.&#xA;$( &amp;quot;div:gt(2)&amp;quot; );&#xA;// All currently animated divs.&#xA;$( &amp;quot;div:animated&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：对于&lt;tr&gt;标签是不适用的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###选择选择器：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Find all &amp;lt;a&amp;gt; elements whose rel attribute ends with &amp;quot;thinger&amp;quot;.&#xA;$( &amp;quot;a[rel$=&#39;thinger&#39;]&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在旧的浏览器中会非常慢，尽可能的用ID/class name/tag name来选择&lt;/p&gt;&#xA;&#xA;&lt;p&gt;选择器在工作时我们一般会先检查是否选中选择，常犯的一个错误是：&#xA;&lt;code&gt;&#xA;// Doesn&#39;t work!&#xA;if ( $( &amp;quot;div.foo&amp;quot; ) ) {&#xA;...&#xA;}&#xA;&lt;/code&gt;&#xA;$()返回的是一个对象，而一个对象一般是true的，即使没有包含任何元素，正确的做法是检查.length属性，这个属性是说明有多少个元素被包含，如果是0的话就是false：&#xA;&lt;code&gt;&#xA;// Testing whether a selection contains elements.&#xA;if ( $( &amp;quot;div.foo&amp;quot; ).length ) {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###报错选择器：&#xA;由于jQuery是不缓存选择器的内容，所以如果需要经常用的元素可以放在一个变量中保存：&#xA;&lt;code&gt;&#xA;var divs = $( &amp;quot;div&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;过滤选择器：&#xA;有一些可能需要选出来的结果过大，需要过滤，例如：&#xA;&lt;code&gt;&#xA;// Refining selections.&#xA;$( &amp;quot;div.foo&amp;quot; ).has( &amp;quot;p&amp;quot; );         // div.foo elements that contain &amp;lt;p&amp;gt; tags&#xA;$( &amp;quot;h1&amp;quot; ).not( &amp;quot;.bar&amp;quot; );           // h1 elements that don&#39;t have a class of bar&#xA;$( &amp;quot;ul li&amp;quot; ).filter( &amp;quot;.current&amp;quot; ); // unordered list items with class of current&#xA;$( &amp;quot;ul li&amp;quot; ).first();              // just the first unordered list item&#xA;$( &amp;quot;ul li&amp;quot; ).eq( 5 );              // the sixth&#xA;&lt;/code&gt;&#xA;选择Form表单元素：&lt;br /&gt;&#xA;:checked&lt;br /&gt;&#xA;可以用于checkbox、radion buttons、selects，不要被checked迷惑&#xA;&lt;code&gt;&#xA;$( &amp;quot;form :checked&amp;quot; );&#xA;&lt;/code&gt;&lt;br /&gt;&#xA;:disabled&lt;br /&gt;&#xA;用于所有disable属性&amp;rdquo;input&amp;rdquo;标签：&#xA;&lt;code&gt;&#xA;$( &amp;quot;form :disabled&amp;quot; );&#xA;&lt;/code&gt;&#xA;:enabled&lt;br /&gt;&#xA;用于选择所有非:disabled属性的元素：&lt;br /&gt;&#xA;&lt;code&gt;&#xA;$( &amp;quot;form :enabled&amp;quot; );&#xA;&lt;/code&gt;&#xA;为了更好的性能，可以使用.filter(&amp;rdquo;:enabled&amp;rdquo;)，或者用其他选择器或者用ID/tag name等选择&lt;/p&gt;&#xA;&#xA;&lt;p&gt;:input&lt;br /&gt;&#xA;用于选择所有&amp;rdquo;input&amp;rdquo;、&amp;rdquo;textarea&amp;rdquo;、&amp;rdquo;select&amp;rdquo;、&amp;rdquo;button&amp;rdquo;元素：&lt;br /&gt;&#xA;&lt;code&gt;&#xA;$( &amp;quot;form :input&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;:selected&lt;br /&gt;&#xA;用于选择&amp;rdquo;option&amp;rdquo;中被选择的选项：&lt;br /&gt;&#xA;&lt;code&gt;&#xA;$( &amp;quot;form :selected&amp;quot; );&#xA;&lt;/code&gt;&#xA;为了性能，可以用.filter(&amp;rdquo;:selected&amp;rdquo;)或者其他选择器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###通过类型选择&#xA;类型包括：&lt;br /&gt;&#xA;:password&lt;br /&gt;&#xA;:reset&lt;br /&gt;&#xA;:radio&lt;br /&gt;&#xA;:text&lt;br /&gt;&#xA;:submit&lt;br /&gt;&#xA;:checkbox&lt;br /&gt;&#xA;:button&#xA;:image&lt;br /&gt;&#xA;:file&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多详细内容见API：  &lt;a href=&#34;http://api.jquery.com/category/selectors/&#34;&gt;http://api.jquery.com/category/selectors/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;#用selections工作&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##Getter 和 Setter&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Setter是作用于选中对象的所有元素，Getter是作用于选用对象的第一个元素：&#xA;&#xA;// The .html() method used as a setter:&#xA;$( &amp;ldquo;h1&amp;rdquo; ).html( &amp;ldquo;hello world&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// The .html() method used as a getter:&#xA;$( &amp;ldquo;h1&amp;rdquo; ).html();&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Setter是返回一个jQuery对象，所以允许你在你选中元素上继续调用jQuery的相关方法，而Getter返回的你请求获取的内容，所以不能继续对其调用jQuery方法：&#xA;&lt;code&gt;&#xA;// Attempting to call a jQuery method after calling a getter.&#xA;// This will NOT work:&#xA;$( &amp;quot;h1&amp;quot; ).html().addClass( &amp;quot;test&amp;quot; );&#xA;&lt;/code&gt;&#xA;链式调用：&lt;br /&gt;&#xA;选择一个元素返回的是一个jQuery对象，所以可以持续调用其方法：&#xA;&lt;code&gt;&#xA;$( &amp;quot;#content&amp;quot; ).find( &amp;quot;h3&amp;quot; ).eq( 2 ).html( &amp;quot;new text for the third h3!&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;等价于以下：&#xA;&lt;code&gt;&#xA;$( &amp;quot;#content&amp;quot; )&#xA;.find( &amp;quot;h3&amp;quot; )&#xA;.eq( 2 )&#xA;.html( &amp;quot;new text for the third h3!&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.end()方法可以回到初始调用的选择节点：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;#content&amp;quot; )&#xA;.find( &amp;quot;h3&amp;quot; )&#xA;.eq( 2 )&#xA;.html( &amp;quot;new text for the third h3!&amp;quot; )&#xA;.end() // Restores the selection to all h3s in #content&#xA;.eq( 0 )&#xA;.html( &amp;quot;new text for the first h3!&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;操作元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取/设置元素信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• .html() – Get or set the HTML contents.&lt;br /&gt;&#xA;• .text() – Get or set the text contents; HTML will be stripped.&lt;br /&gt;&#xA;• .attr() – Get or set the value of the provided attribute.&lt;br /&gt;&#xA;• .width() – Get or set the width in pixels of the first element in the selection as an integer.&lt;br /&gt;&#xA;• .height() – Get or set the height in pixels of the first element in the selection as an integer.&lt;br /&gt;&#xA;• .position() – Get an object with position information for the first element in the selection, relative to its first positioned ancestor. This is a getter only.&lt;br /&gt;&#xA;• .val() – Get or set the value of form elements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##移动、复制、删除元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;操作DOM大致分成两种情况：&lt;br /&gt;&#xA;1.将选择元素放置在某个元素的某个相对位置&lt;br /&gt;&#xA;2.将某个元素放置在选择元素的某个相对位置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery提供了.intertAfter()和.after()方法，.intertAfter()是通过将某个元素作为参数来达到将选择元素放在该元素之后，.after()是通过某个元素作为参数来达到将该元素放在选择元素之后的效果。同样的还有.insertBefor()和.before()，apptendTo()和append(),.prependTo()和pretend()。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Moving elements using different approaches.&#xA;// Make the first list item the last list item:&#xA;var li = $( &amp;quot;#myList li:first&amp;quot; ).appendTo( &amp;quot;#myList&amp;quot; );&#xA;// Another approach to the same problem:&#xA;$( &amp;quot;#myList&amp;quot; ).append( $( &amp;quot;#myList li:first&amp;quot; ) );&#xA;// Note that there&#39;s no way to access the list item&#xA;// that we moved, as this returns the list itself.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;复制元素：&lt;br /&gt;&#xA;通过.clone()方法复制元素，例如复制同样一个元素加载li最后：&lt;br /&gt;&#xA;&lt;code&gt;&#xA;// Making a copy of an element.&#xA;// Copy the first list item to the end of the list:&#xA;$( &amp;quot;#myList li:first&amp;quot; ).clone().appendTo( &amp;quot;#myList&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;移除元素：&lt;br /&gt;&#xA;通过remove()和detach()两个方法移除，两者的不同是：&lt;br /&gt;&#xA;remove()是永久的删除该元素，并且返回该元素，但是不会返回该元素相关联的数据和事件，&#xA;而detach()是返回删除元素以及该元素相关联的数据和时间，可以存储一遍后面使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果只是移除元素中的内容，可以使用.empty()方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建一个新元素：&lt;br /&gt;&#xA;jQuery提供了$()方法创建新元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Creating new elements from an HTML string.&#xA;$( &amp;quot;&amp;lt;p&amp;gt;This is a new paragraph&amp;lt;/p&amp;gt;&amp;quot; );&#xA;$( &amp;quot;&amp;lt;li class=\&amp;quot;new\&amp;quot;&amp;gt;new list item&amp;lt;/li&amp;gt;&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也可以这样：&#xA;&lt;code&gt;&#xA;// Creating a new element with an attribute object.&#xA;$( &amp;quot;&amp;lt;a/&amp;gt;&amp;quot;, {&#xA;html: &amp;quot;This is a &amp;lt;strong&amp;gt;new&amp;lt;/strong&amp;gt; link&amp;quot;,&#xA;    &amp;quot;class&amp;quot;: &amp;quot;new&amp;quot;,&#xA;    href: &amp;quot;foo.html&amp;quot;&#xA;});&#xA;&lt;/code&gt;&#xA;需要注意的是一般情况下属性是不用双引号，出发是reserved words，例如上面的class&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你创建一个元素不会立即增加到页面中，可以通过以下几种方式增加到页面中去：&#xA;&lt;code&gt;&#xA;// Getting a new element on to the page.&#xA;var myNewElement = $( &amp;quot;&amp;lt;p&amp;gt;New element&amp;lt;/p&amp;gt;&amp;quot; );&#xA;myNewElement.appendTo( &amp;quot;#content&amp;quot; );&#xA;myNewElement.insertAfter( &amp;quot;ul:last&amp;quot; ); // This will remove the p from #content!&#xA;$( &amp;quot;ul&amp;quot; ).last().after( myNewElement.clone() ); // Clone the p so now we have two.&#xA;&lt;/code&gt;&#xA;也可以不用将创建的元素报错在操作，可以直接操作：&#xA;&lt;code&gt;&#xA;// Creating and adding an element to the page at the same time.&#xA;$( &amp;quot;ul&amp;quot; ).append( &amp;quot;&amp;lt;li&amp;gt;list item&amp;lt;/li&amp;gt;&amp;quot; );&#xA;&lt;/code&gt;&#xA;也可以用一个数组将元素保存，最后将数组放入一个字符串加入：&#xA;&lt;code&gt;&#xA;var myItems = [];&#xA;var myList = $( &amp;quot;#myList&amp;quot; );&#xA;for ( var i = 0; i &amp;lt; 100; i++ ) {&#xA;    myItems.push( &amp;quot;&amp;lt;li&amp;gt;item &amp;quot; + i + &amp;quot;&amp;lt;/li&amp;gt;&amp;quot; );&#xA;}&#xA;myList.append( myItems.join( &amp;quot;&amp;quot; ) );&#xA;&lt;/code&gt;&#xA;操作元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Manipulating a single attribute.&#xA;$( &amp;quot;#myDiv a:first&amp;quot; ).attr( &amp;quot;href&amp;quot;, &amp;quot;newDestination.html&amp;quot; );&#xA;&#xA;&#xA;// Manipulating multiple attributes.&#xA;$( &amp;quot;#myDiv a:first&amp;quot; ).attr({&#xA;    href: &amp;quot;newDestination.html&amp;quot;,&#xA;    rel: &amp;quot;nofollow&amp;quot;&#xA;});&#xA;&#xA;&#xA;// Using a function to determine an attribute&#39;s new value.&#xA;$( &amp;quot;#myDiv a:first&amp;quot; ).attr({&#xA;    rel: &amp;quot;nofollow&amp;quot;,&#xA;    href: function( idx, href ) {&#xA;        return &amp;quot;/new/&amp;quot; + href;&#xA;    }&#xA;});&#xA;$( &amp;quot;#myDiv a:first&amp;quot; ).attr( &amp;quot;href&amp;quot;, function( idx, href ) {&#xA;    return &amp;quot;/new/&amp;quot; + href;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;#The jQuery Object&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery Object相对于元素DOM元素的两大好处：&lt;br /&gt;&#xA;1.兼容性：&#xA;&lt;code&gt;&#xA;var target = document.getElementById( &amp;quot;target&amp;quot; );&#xA;target.innerHTML = &amp;quot;&amp;lt;td&amp;gt;Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!&amp;lt;/td&amp;gt;&amp;quot;;&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个在很多浏览器中是可以实现的，但是在大部分IE中是不支持的，但是通过将target元素包装成jQuery Object，就可以方便的通过如下代码在各个jQuery支持的浏览器中运行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Setting the inner HTML with jQuery.&#xA;var target = document.getElementById( &amp;quot;target&amp;quot; );&#xA;$( target ).html( &amp;quot;&amp;lt;td&amp;gt;Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!&amp;lt;/td&amp;gt;&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.方便性：&#xA;有时候操作原生的DOM方法也比较麻烦，例如新建一个元素newElement准备放在目标元素target之后，原生DOM方法操作如下：&#xA;&lt;code&gt;&#xA;// Inserting a new element after another with the native DOM API.&#xA;var target = document.getElementById( &amp;quot;target&amp;quot; );&#xA;var newElement = document.createElement( &amp;quot;div&amp;quot; );&#xA;target.parentNode.insertBefore( newElement, target.nextSibling );&#xA;&lt;/code&gt;&#xA;但是通过将目标元素target保证成jQuery对象之后，就可以:&#xA;&lt;code&gt;&#xA;// Inserting a new element after another with jQuery.&#xA;var target = document.getElementById( &amp;quot;target&amp;quot; );&#xA;var newElement = document.createElement( &amp;quot;div&amp;quot; );&#xA;$( target ).after( newElement );&#xA;&lt;/code&gt;&#xA;获得jQuery对象中的元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当用CSS选择器的时候得到的jQuery对象包含所有符合条件的元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting all &amp;lt;h1&amp;gt; tags.&#xA;var headings = $( &amp;quot;h1&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;headings包含所有&amp;rdquo;h1&amp;rdquo;标签的元素，可以通过headings的.length属性验证：&#xA;&lt;code&gt;&#xA;// Viewing the number of &amp;lt;h1&amp;gt; tags on the page.&#xA;var headings = $( &amp;quot;h1&amp;quot; );&#xA;alert( headings.length );&#xA;&lt;/code&gt;&#xA;如果目标是只要获取第一个&amp;rdquo;h1&amp;rdquo;标签的元素，可以通过.eq()方法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting only the first &amp;lt;h1&amp;gt; element on the page (in a jQuery object)&#xA;var headings = $( &amp;quot;h1&amp;quot; );&#xA;var firstHeading = headings.eq( 0 );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;firstHeading是一个jQuery对象，可以使用.html()、.after()等方法，jQuery还提供了一个.get()方法，返回DOM元素，而不是jQuery包装的DOM元素：&#xA;&lt;code&gt;&#xA;// Selecting only the first &amp;lt;h1&amp;gt; element on the page.&#xA;var firstHeadingElem = $( &amp;quot;h1&amp;quot; ).get( 0 );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于jQuery对象是类似数组，以上代码等价于：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting only the first &amp;lt;h1&amp;gt; element on the page (alternate approach).&#xA;var firstHeadingElem = $( &amp;quot;h1&amp;quot; )[ 0 ];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;此时firstHeadingElem是元素DOM元素，具有DOM元素的属性，例如innerHTML，和方法例如.appendChild()，但是没有jQuery对象的方法例如.html()和.after()。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery对象包装时确保了唯一，及时获取同一个元素的对象，两者===是不相等的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Creating two jQuery objects for the same element.&#xA;var logo1 = $( &amp;quot;#logo&amp;quot; );&#xA;var logo2 = $( &amp;quot;#logo&amp;quot; );&#xA;&#xA;// Comparing jQuery objects.&#xA;alert( $( &amp;quot;#logo&amp;quot; ) === $( &amp;quot;#logo&amp;quot; ) ); // alerts &amp;quot;false&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是.get()方法可以获取元素DOM元素，所以可以比较两个jQuery对象是否相等：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Comparing DOM elements.&#xA;var logo1 = $( &amp;quot;#logo&amp;quot; );&#xA;var logo1Elem = logo1.get( 0 );&#xA;var logo2 = $( &amp;quot;#logo&amp;quot; );&#xA;var logo2Elem = logo2.get( 0 );&#xA;alert( logo1Elem === logo2Elem ); // alerts &amp;quot;true&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;#Traversing&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多具体可见&lt;a href=&#34;http://api.jquery.com/category/traversing/&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##Parents:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;grandparent&amp;quot;&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt;&#xA;        &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&#xA;            &amp;lt;span class=&amp;quot;subchild&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;surrogateParent1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;    &amp;lt;div class=&amp;quot;surrogateParent2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Parents:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting an element&#39;s direct parent:&#xA;// returns [ div.child ]&#xA;$( &amp;quot;span.subchild&amp;quot; ).parent();&#xA;// Selecting all the parents of an element that match a given selector:&#xA;// returns [ div.parent ]&#xA;$( &amp;quot;span.subchild&amp;quot; ).parents( &amp;quot;div.parent&amp;quot; );&#xA;// returns [ div.child, div.parent, div.grandparent ]&#xA;$( &amp;quot;span.subchild&amp;quot; ).parents();&#xA;// Selecting all the parents of an element up to, but *not including* the selector:&#xA;// returns [ div.child, div.parent ]&#xA;$( &amp;quot;span.subchild&amp;quot; ).parentsUntil( &amp;quot;div.grandparent&amp;quot; );&#xA;// Selecting the closest parent, note that only one parent will be selected&#xA;// and that the initial element itself is included in the search:&#xA;// returns [ div.child ]&#xA;$( &amp;quot;span.subchild&amp;quot; ).closest( &amp;quot;div&amp;quot; );&#xA;// returns [ div.child ] as the selector is also included in the search:&#xA;$( &amp;quot;div.child&amp;quot; ).closest( &amp;quot;div&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Children:&#xA;jQuery中获取子元素可以通过.children()和.find()方法，两者的不同是.children()获取直接子元素，.find()是可以递归获取所有子元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;&#xA;// Selecting an element&#39;s direct children:&#xA;// returns [ div.parent, div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;quot;div.grandparent&amp;quot; ).children( &amp;quot;div&amp;quot; );&#xA;// Finding all elements within a selection that match the selector:&#xA;// returns [ div.child, div.parent, div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;quot;div.grandparent&amp;quot; ).find( &amp;quot;div&amp;quot; );&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Siblings&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相邻子节点的获取有多个方法，.prev()是获取前一个元素，.next()是获取下一个元素，.siblings()是获取前后两个元素，还有.nextAll(), .nextUntil(), .prevAll(), .prevUntil()：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting a next sibling of the selectors:&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;quot;div.parent&amp;quot; ).next();&#xA;// Selecting a prev sibling of the selectors:&#xA;// returns [] as No sibling exists before div.parent&#xA;$( &amp;quot;div.parent&amp;quot; ).prev();&#xA;// Selecting all the next siblings of the selector:&#xA;// returns [ div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;quot;div.parent&amp;quot; ).nextAll();&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;quot;div.parent&amp;quot; ).nextAll().first();&#xA;// returns [ div.surrogateParent2 ]&#xA;$( &amp;quot;div.parent&amp;quot; ).nextAll().last();&#xA;// Selecting all the previous siblings of the selector:&#xA;// returns [ div.surrogateParent1, div.parent ]&#xA;$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll();&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll().first();&#xA;// returns [ div.parent ]&#xA;$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll().last();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;.siblings()获取所有相邻子元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Selecting an element&#39;s siblings in both directions that matches the given selector:&#xA;// returns [ div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;quot;div.parent&amp;quot; ).siblings();&#xA;// returns [ div.parent, div.surrogateParent2 ]&#xA;$( &amp;quot;div.surrogateParent1&amp;quot; ).siblings();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;CSS, Styling, &amp;amp; Dimensions&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery中有方便的方法操作CSS元素的属性：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Getter：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Getting CSS properties.&#xA;$( &amp;quot;h1&amp;quot; ).css( &amp;quot;fontSize&amp;quot; ); // Returns a string such as &amp;quot;19px&amp;quot;.&#xA;$( &amp;quot;h1&amp;quot; ).css( &amp;quot;font-size&amp;quot; ); // Also works.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Setter：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Setting CSS properties.&#xA;$( &amp;quot;h1&amp;quot; ).css( &amp;quot;fontSize&amp;quot;, &amp;quot;100px&amp;quot; ); // Setting an individual property.&#xA;// Setting multiple properties.&#xA;$( &amp;quot;h1&amp;quot; ).css({&#xA;    fontSize: &amp;quot;100px&amp;quot;,&#xA;    color: &amp;quot;red&amp;quot;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;CSS的属性在JavaScript中调用都是要通过将&amp;rsquo;-&amp;lsquo;修改成驼峰标识，例如CSS属性font-size在JavaScript中使用fontSize&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.css()是不稳定的，在生产中要尽量不用，而是将CSS规则放在class中然后通过改变元素的class属性达到效果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Working with classes.&#xA;var h1 = $( &amp;quot;h1&amp;quot; );&#xA;h1.addClass( &amp;quot;big&amp;quot; );&#xA;h1.removeClass( &amp;quot;big&amp;quot; );&#xA;h1.toggleClass( &amp;quot;big&amp;quot; );&#xA;if ( h1.hasClass( &amp;quot;big&amp;quot; ) ) {&#xA;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;尺寸（Dimensions），具体可见API： &lt;a href=&#34;http://api.jquery.com/category/dimensions/&#34;&gt;http://api.jquery.com/category/dimensions/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Basic dimensions methods.&#xA;// Sets the width of all &amp;lt;h1&amp;gt; elements.&#xA;$( &amp;quot;h1&amp;quot; ).width( &amp;quot;50px&amp;quot; );&#xA;// Gets the width of the first &amp;lt;h1&amp;gt; element.&#xA;$( &amp;quot;h1&amp;quot; ).width();&#xA;// Sets the height of all &amp;lt;h1&amp;gt; elements.&#xA;$( &amp;quot;h1&amp;quot; ).height( &amp;quot;50px&amp;quot; );&#xA;// Gets the height of the first &amp;lt;h1&amp;gt; element.&#xA;$( &amp;quot;h1&amp;quot; ).height();&#xA;// Returns an object containing position information for&#xA;// the first &amp;lt;h1&amp;gt; relative to its &amp;quot;offset (positioned) parent&amp;quot;.&#xA;$( &amp;quot;h1&amp;quot; ).position();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;##Data Methods&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用的元素操作时的数据操作方法，jQuery提供了直接的方法操作，而不用开发者关心内存问题：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Storing and retrieving data related to an element.&#xA;$( &amp;quot;#myDiv&amp;quot; ).data( &amp;quot;keyName&amp;quot;, { foo: &amp;quot;bar&amp;quot; } );&#xA;$( &amp;quot;#myDiv&amp;quot; ).data( &amp;quot;keyName&amp;quot; ); // Returns { foo: &amp;quot;bar&amp;quot; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Utility Methods&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在$命名空间中有一些实用的方法，具体可见API： &lt;a href=&#34;http://api.jquery.com/category/utilities/&#34;&gt;http://api.jquery.com/category/utilities/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.trim()：剔除字符串两头空白串&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Returns &amp;quot;lots of extra whitespace&amp;quot;&#xA;$.trim( &amp;quot;    lots of extra whitespace    &amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$.each()：遍历数组或者对象&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.each([ &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ], function( idx, val ) {&#xA;    console.log( &amp;quot;element &amp;quot; + idx + &amp;quot; is &amp;quot; + val );&#xA;});&#xA;$.each({ foo: &amp;quot;bar&amp;quot;, baz: &amp;quot;bim&amp;quot; }, function( k, v ) {&#xA;    console.log( k + &amp;quot; : &amp;quot; + v );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$.each()可以在选择元素上被调用，遍历选中元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.inArray()：返回数组中值的索引值，如果没有返回-1&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var myArray = [ 1, 2, 3, 5 ];&#xA;if ( $.inArray( 4, myArray ) !== -1 ) {&#xA;    console.log( &amp;quot;found it!&amp;quot; );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$.extend():用后续对象的属性替换第一个对象的属性：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var firstObject = { foo: &amp;quot;bar&amp;quot;, a: &amp;quot;b&amp;quot; };&#xA;var secondObject = { foo: &amp;quot;baz&amp;quot; };&#xA;var newObject = $.extend( firstObject, secondObject );&#xA;console.log( firstObject.foo ); // &amp;quot;baz&amp;quot;&#xA;console.log( newObject.foo ); // &amp;quot;baz&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果不想改变传进去的任何一个对象，可以在第一个参数传一个空对象：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var firstObject = { foo: &amp;quot;bar&amp;quot;, a: &amp;quot;b&amp;quot; };&#xA;var secondObject = { foo: &amp;quot;baz&amp;quot; };&#xA;var newObject = $.extend( {}, firstObject, secondObject );&#xA;console.log( firstObject.foo ); // &amp;quot;bar&amp;quot;&#xA;console.log( newObject.foo ); // &amp;quot;baz&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$.proxy()：将作为参数传进来的函数中的this指向第二个传进来的参数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var myFunction = function() {&#xA;console.log( this );&#xA;};&#xA;var myObject = {&#xA;foo: &amp;quot;bar&amp;quot;&#xA;};&#xA;myFunction(); // window&#xA;var myProxyFunction = $.proxy( myFunction, myObject );&#xA;myProxyFunction(); // myObject&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;myObject作为第二个参数，被当作第一个参数myFunction函数中的this&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果有一个有方法的对象，可以传递该对象和对象方法的名称，那么方法的作用域还是在对象中：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var myObject = {&#xA;    myFn: function() {&#xA;        console.log( this );&#xA;    }&#xA;};&#xA;$( &amp;quot;#foo&amp;quot; ).click( myObject.myFn ); // HTMLElement #foo&#xA;$( &amp;quot;#foo&amp;quot; ).click( $.proxy( myObject, &amp;quot;myFn&amp;quot; ) ); // myObject&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Testing Type&#xA;测试类型typeof经常令人疑惑，所以jQuery提供了一些实用方法来代替：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.isArray([]); // true&#xA;$.isFunction(function() {}); // true&#xA;$.isNumeric(3.14); // true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$.type()检查创建值使用的内建类，这个是比typeof操作符更好的选择：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.type( true ); // &amp;quot;boolean&amp;quot;&#xA;$.type( 3 ); // &amp;quot;number&amp;quot;&#xA;$.type( &amp;quot;test&amp;quot; ); // &amp;quot;string&amp;quot;&#xA;$.type( function() {} ); // &amp;quot;function&amp;quot;&#xA;$.type( new Boolean() ); // &amp;quot;boolean&amp;quot;&#xA;$.type( new Number(3) ); // &amp;quot;number&amp;quot;&#xA;$.type( new String(&#39;test&#39;) ); // &amp;quot;string&amp;quot;&#xA;$.type( new Function() ); // &amp;quot;function&amp;quot;&#xA;$.type( [] ); // &amp;quot;array&amp;quot;&#xA;$.type( null ); // &amp;quot;null&amp;quot;&#xA;$.type( /test/ ); // &amp;quot;regexp&amp;quot;&#xA;$.type( new Date() ); // &amp;quot;date&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;jQuery中的type可见： &lt;a href=&#34;http://api.jquery.com/jQuery.type/&#34;&gt;http://api.jquery.com/jQuery.type/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##Iterating over jQuery and non-jQuery Objects&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each()是一个通用的遍历方法，遍历对象、数组、以及类数组的对象，空白对象通过命名属性遍历、数组和类数组对象通过索引：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var sum = 0;&#xA;var arr = [ 1, 2, 3, 4, 5 ];&#xA;&#xA;for ( var i = 0, l = arr.length; i &amp;lt; l; i++ ) {&#xA;    sum += arr[ i ];&#xA;}&#xA;console.log( sum ); // 15&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;等价于：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.each( arr, function( index, value ){&#xA;    sum += value;&#xA;});&#xA;console.log( sum ); // 15&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们不用通过arr[index]作为值传给$.each()的回调函数，另外：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var sum = 0;&#xA;var obj = {&#xA;    foo: 1,&#xA;    bar: 2&#xA;}&#xA;&#xA;for (var item in obj) {&#xA;    sum += obj[ item ];&#xA;}&#xA;console.log( sum ); // 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;等价于：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.each( obj, function( key, value ) {&#xA;    sum += value;&#xA;});&#xA;console.log( sum ); // 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同样，我们不用obj[key]来作为值传给$each()的回调函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：$.each()是给空白对象(plain objects)、数组(arrays)、类数组对象(array-like objects)而不是jQuery集合，以下是错误的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Incorrect:&#xA;$.each( $( &amp;quot;p&amp;quot; ), function() {&#xA;    // Do something&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;.each()：是给jQuery集合用的，匹配元素后通过一个回调函数执行，该元素的索引和值都被当作回调函数的参数传入，回调函数执行时上下文是匹配的元素，所以回调函数中this关键字就是当前匹配的元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&#xA;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Link 1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Link 2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Link 3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&#xA;&#xA;$( &amp;quot;li&amp;quot; ).each( function( index, element ){&#xA;    console.log( $( this ).text() );&#xA;});&#xA;// Logs the following:&#xA;// Link 1&#xA;// Link 2&#xA;// Link 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;既然this是当前匹配的元素，那么为何回调函数中第二个参数也是当前匹配的元素？这是一个经常被问到的问题。&#xA;因为不断的用this经常会让人疑惑不易读，所以回调函数的第二个参数来处理。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;li&amp;quot; ).each( function( index, listItem ) {&#xA;    this === listItem; // true&#xA;    // For example only. You probably shouldn&#39;t call $.ajax() in a loop.&#xA;    $.ajax({&#xA;        success: function( data ) {&#xA;        // The context has changed.&#xA;        // The &amp;quot;this&amp;quot; keyword no longer refers to listItem.&#xA;        this !== listItem; // true&#xA;        }&#xA;    });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;有时候.each()是不必要的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;li&amp;quot; ).each( function( index, el ) {&#xA;    $( el ).addClass( &amp;quot;newClass&amp;quot; );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以用以下代码代替：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;li&amp;quot; ).addClass( &amp;quot;newClass&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;有时候一些方法不能遍历集合，这个时候在设置新值之前需要获取元素当前值时.each()就可以有用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Doesn&#39;t work:&#xA;$( &amp;quot;input&amp;quot; ).val( $( this ).val() + &amp;quot;%&amp;quot; );&#xA;// .val() does not change the execution context, so this === window&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;应该这样写：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;input&amp;quot; ).each( function( i, el ) {&#xA;    var elem = $( el );&#xA;    elem.val( elem.val() + &amp;quot;%&amp;quot; );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以下方法都需要.each()：&lt;br /&gt;&#xA;• .attr() (getter)&lt;br /&gt;&#xA;• .css() (getter)&lt;br /&gt;&#xA;• .data() (getter)&lt;br /&gt;&#xA;• .height() (getter)&lt;br /&gt;&#xA;• .html() (getter)&lt;br /&gt;&#xA;• .innerHeight()&lt;br /&gt;&#xA;• .innerWidth()&lt;br /&gt;&#xA;• .offset() (getter)&lt;br /&gt;&#xA;• .outerHeight()&lt;br /&gt;&#xA;• .outerWidth()&#xA;• .position()&lt;br /&gt;&#xA;• .prop() (getter)&lt;br /&gt;&#xA;• .scrollLeft() (getter)&lt;br /&gt;&#xA;• .scrollTop() (getter)&lt;br /&gt;&#xA;• .val() (getter)&lt;br /&gt;&#xA;• .width() (getter)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大多数情况，上面有getter标记的返回jQuery集合第一个元素的值而setter是对所有匹配的元素都有操作，需要注意的是.text()将会返回所有匹配元素的字符串拼接。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外设置值、属性等可以用匿名回调函数匹配元素，回调函数的参数是匹配元素的索引和getter方法的结果值，一下两个写法效果相同：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;input&amp;quot; ).each( function( i, el ) {&#xA;    var elem = $( el );&#xA;    elem.val( elem.val() + &amp;quot;%&amp;quot; );&#xA;});&#xA;&#xA;$( &amp;quot;input&amp;quot; ).val(function( index, value ) {&#xA;    return value + &amp;quot;%&amp;quot;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;.map()&#xA;如果我们想将匹配的元素创建为一个数组或者连接字符串，此时用.map()：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var newArr = [];&#xA;$( &amp;quot;li&amp;quot; ).each( function() {&#xA;    newArr.push( this.id );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以这样做：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;li&amp;quot; ).map( function(index, element) {&#xA;    return this.id;&#xA;}).get();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意：.map()返回的是jQuery包装的集合对象，而.get()返回JavaScript原生的对象，如果想拼接字符串，可以用元素的JavaScript的.join()方法在get()之后调用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.map&#xA;$.map()和.map()的区别于$.each()和.each()的区别类似，$.map()是作用于JavaScript的原生数组而.map()是作用于jQuery元素集合的。因为$.map()作用域JavaScript原生数组，所以返回的也是JavaScript原生数组，不需要通过.get()方法得到JavaScript原生数组，如果用了的话会报错。&#xA;需要注意的是$.map()的参数顺序有变化，第一个参数是value，第二个参数是index，这么做是因为本地的JavaScript的.map()方法需要可用(ECMAScript5标准)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;li id=&amp;quot;a&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;b&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;c&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;var arr = [{&#xA;    id: &amp;quot;a&amp;quot;,&#xA;    tagName: &amp;quot;li&amp;quot;&#xA;}, {&#xA;    id: &amp;quot;b&amp;quot;,&#xA;    tagName: &amp;quot;li&amp;quot;&#xA;}, {&#xA;    id: &amp;quot;c&amp;quot;,&#xA;    tagName: &amp;quot;li&amp;quot;&#xA;}];&#xA;// Returns [ &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot; ]&#xA;$( &amp;quot;li&amp;quot; ).map( function( index, element ) {&#xA;    return element.id;&#xA;}).get();&#xA;&#xA;// Also returns [ &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot; ]&#xA;// Note that the value comes first with $.map&#xA;$.map( arr, function( value, index ) {&#xA;    return value.id;&#xA;});&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;#Using jQuery’s .index() Function&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.index()无参数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&#xA;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;li id=&amp;quot;foo1&amp;quot;&amp;gt;foo&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;bar1&amp;quot;&amp;gt;bar&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;baz1&amp;quot;&amp;gt;baz&amp;lt;/li&amp;gt;&#xA;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&#xA;var foo = $( &amp;quot;#foo1&amp;quot; );&#xA;console.log( &amp;quot;Index: &amp;quot; + foo.index() ); // 1&#xA;var listItem = $( &amp;quot;li&amp;quot; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;quot;Index: &amp;quot; + listItem.index() ); // 1&#xA;console.log( &amp;quot;Index: &amp;quot; + listItem.first().index() ); // 1&#xA;var div = $( &amp;quot;div&amp;quot; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;quot;Index: &amp;quot; + div.index() ); // 0&#xA;console.log( &amp;quot;Index: &amp;quot; + div.first().index() ); // 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;.index()用string作为参数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&#xA;&amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;li id=&amp;quot;foo1&amp;quot;&amp;gt;foo&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;bar1&amp;quot; class=&amp;quot;test&amp;quot;&amp;gt;bar&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;baz1&amp;quot;&amp;gt;baz&amp;lt;/li&amp;gt;&#xA;&amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&amp;lt;div id=&amp;quot;last&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;var foo = $( &amp;quot;li&amp;quot; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;quot;Index: &amp;quot; + foo.index( &amp;quot;li&amp;quot; ) ); // 0&#xA;console.log( &amp;quot;Index: &amp;quot; + foo.first().index( &amp;quot;li&amp;quot; ) ); // 0&#xA;var baz = $( &amp;quot;#baz1&amp;quot; );&#xA;console.log( &amp;quot;Index: &amp;quot; + baz.index( &amp;quot;li&amp;quot; )); // 2&#xA;var listItem = $( &amp;quot;#bar1&amp;quot; );&#xA;console.log( &amp;quot;Index: &amp;quot; + listItem.index( &amp;quot;.test&amp;quot; ) ); // 1&#xA;var div = $( &amp;quot;#last&amp;quot; );&#xA;console.log( &amp;quot;Index: &amp;quot; + div.index( &amp;quot;div&amp;quot; ) ); // 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;.index()使用jQuery对象调用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&#xA;&amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;li id=&amp;quot;foo1&amp;quot;&amp;gt;foo&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;bar1&amp;quot; class=&amp;quot;test&amp;quot;&amp;gt;bar&amp;lt;/li&amp;gt;&#xA;&amp;lt;li id=&amp;quot;baz1&amp;quot;&amp;gt;baz&amp;lt;/li&amp;gt;&#xA;&amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&amp;lt;div id=&amp;quot;last&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&#xA;&#xA;var foo = $( &amp;quot;li&amp;quot; );&#xA;var baz = $( &amp;quot;#baz1&amp;quot; );&#xA;console.log( &amp;quot;Index: &amp;quot; + foo.index( baz ) ); // 2&#xA;var tests = $( &amp;quot;.test&amp;quot; );&#xA;var bar = $( &amp;quot;#bar1&amp;quot; );&#xA;// Implicitly calls .first() on the argument.&#xA;console.log( &amp;quot;Index: &amp;quot; + tests.index( bar ) ); // 1&#xA;console.log( &amp;quot;Index: &amp;quot; + tests.index( bar.first() ) ); // 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>jQuery学习笔记1</title>
      <link>http://www.wowzai.com/2015/JavaScript-notes.html</link>
      <pubDate>2015-05-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.ready事件，event.preventDefault()组织默认程序执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://jquery.com/&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&#xA;    &amp;lt;script src=&amp;quot;scripts/jquery-1.11.2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script&amp;gt;&#xA;        $(document).ready(function() {&#xA;            $(&amp;quot;a&amp;quot;).click(function( event ) {&#xA;                alert( &amp;quot;As you can see, the link no longer took you to jquery.com&amp;quot; ); &#xA;                event.preventDefault();&#xA;            });&#xA;       });&#xA;  &amp;lt;/script&amp;gt; &#xA;&#xA;$( &amp;quot;a&amp;quot; ).addClass( &amp;quot;test&amp;quot; );&#xA;&#xA;$( &amp;quot;a&amp;quot; ).removeClass( &amp;quot;test&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.回调&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无参数的：   &lt;code&gt;$.get( &amp;quot;myhtmlpage.html&amp;quot;, myCallBack );&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.get()完成之后会执行myCallBack()函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有参数的：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正确做法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.get( &amp;quot;myhtmlpage.html&amp;quot;, function() {&#xA;    myCallBack( param1, param2 );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;错误做法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.get( &amp;quot;myhtmlpage.html&amp;quot;, myCallBack( param1, param2 ) );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这种做法会立即执行myCallBack( param1, param2 )，把myCallBack( param1, param2 )的执行结果当作$.get()的第二个参数&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;$-vs-$()&#34; href=&#34;#$-vs-$()&#34;&gt;&lt;/a&gt;$ vs $()&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;$()：  是命名空间$.fn中选择器，并且自动把选择的节点作为this传递给函数并返回，eg: $(&amp;ldquo;h1&amp;rdquo;).remove()&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$：调用$命名空间中的实用方法，eg&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$.trim(&amp;quot;  lots of extra whitespace  &amp;quot;) //return &amp;quot;lots of extra whitespace&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更多实用方法：     &lt;a href=&#34;http://learn.jquery.com/using-jquery-core/utility-methods/&#34;&gt;文档1&lt;/a&gt;、&lt;a href=&#34;http://api.jquery.com/category/utilities/&#34;&gt;文档2&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##$( document ).ready()&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$(document).ready()只有在页面的Document Object Model (DOM)加载好了之后就可以执行，而&#xA;$( window ).load(function() { &amp;hellip; }) 只有在整个页面（包括图片、iframe）加载完成之后才可以执行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;    &amp;lt;script src=&amp;quot;scripts/jquery-1.11.2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script&amp;gt;&#xA;        $( document ).ready(function() {&#xA;            console.log( &amp;quot;document loaded&amp;quot; );  //页面DOM加载完成即打印&#xA;        });&#xA;        $( window ).load(function() {&#xA;            console.log( &amp;quot;window loaded&amp;quot; );   //页面DOM加载完成即打印&#xA;        });&#xA;    &amp;lt;/script&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;    &amp;lt;iframe src=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Avoiding Conflicts with Other Libraries&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三种方法：&lt;br /&gt;&#xA;1.用一个新的命名，加载是必须放在别的库的后面：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;// Give $ back to prototype.js; create new alias to jQuery.&#xA;var $jq = jQuery.noConflict();&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.当作一个函数调用，加载是放在别的库之前：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Using the $ inside an immediately-invoked function expression. --&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    jQuery.noConflict();&#xA;    (function( $ ) {&#xA;        // Your jQuery code here, using the $&#xA;    })( jQuery );&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3.当作函数参数传递，加载是放在别的库之前：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    jQuery(document).ready(function( $ ) {&#xA;        // Your jQuery code here, using $ to refer to jQuery.&#xA;    });&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者换成一种容易让人疑惑但是也是正确的写法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;prototype.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;    jQuery(function($){&#xA;        // Your jQuery code here, using the $&#xA;    });&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Attributes&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.attr()方法及当作getter也当作setter，.attr()可以接受一个键及其对应的值，也可以接受一个包含一个或多个键值对的对象：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当作setter:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;a&amp;quot; ).attr( &amp;quot;href&amp;quot;, &amp;quot;allMyHrefsAreTheSameNow.html&amp;quot; );&#xA;$( &amp;quot;a&amp;quot; ).attr({&#xA;    title: &amp;quot;all titles are the same too!&amp;quot;,&#xA;    href: &amp;quot;somethingNew.html&amp;quot;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当作getter:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;a&amp;quot; ).attr( &amp;quot;href&amp;quot; ); // Returns the href for the first a element in the document&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;##Selecting Elements&lt;/p&gt;&#xA;&#xA;&lt;p&gt;来自&lt;a href=&#34;http://learn.jquery.com/using-jquery-core/selecting-elements/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过ID获取：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;#myId&amp;quot; ); // Note IDs must be unique per page.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过Class Name获取：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;.myClass&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过属性获取：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;input[name=&#39;first_name&#39;]&amp;quot; ); // Beware, this can be very slow in older browsers&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过复核CSS选择器：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;#contents ul.people li&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;伪选择器：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;a.external:first&amp;quot; );&#xA;$( &amp;quot;tr:odd&amp;quot; );&#xA;// Select all input-like elements in a form (more on this below).&#xA;$( &amp;quot;#myForm :input&amp;quot; );&#xA;$( &amp;quot;div:visible&amp;quot; );&#xA;// All except the first three divs.&#xA;$( &amp;quot;div:gt(2)&amp;quot; );&#xA;// All currently animated divs.&#xA;$( &amp;quot;div:animated&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意：对于&lt;tr&gt;标签是不适用的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;选择选择器：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Find all &amp;lt;a&amp;gt; elements whose rel attribute ends with &amp;quot;thinger&amp;quot;.&#xA;$( &amp;quot;a[rel$=&#39;thinger&#39;]&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在旧的浏览器中会非常慢，尽可能的用ID/class name/tag name来选择&lt;/p&gt;&#xA;&#xA;&lt;p&gt;选择器在工作时我们一般会先检查是否选中选择，常犯的一个错误是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Doesn&#39;t work!&#xA;if ( $( &amp;quot;div.foo&amp;quot; ) ) {&#xA;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$()返回的是一个对象，而一个对象一般是true的，即使没有包含任何元素，正确的做法是检查.length属性，这个属性是说明有多少个元素被包含，如果是0的话就是false：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Testing whether a selection contains elements.&#xA;if ( $( &amp;quot;div.foo&amp;quot; ).length ) {&#xA;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;报错选择器：&#xA;由于jQuery是不缓存选择器的内容，所以如果需要经常用的元素可以放在一个变量中保存：&#xA;    var divs = $( &amp;ldquo;div&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;过滤选择器：&#xA;有一些可能需要选出来的结果过大，需要过滤，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Refining selections.&#xA;$( &amp;quot;div.foo&amp;quot; ).has( &amp;quot;p&amp;quot; ); // div.foo elements that contain &amp;lt;p&amp;gt; tags&#xA;$( &amp;quot;h1&amp;quot; ).not( &amp;quot;.bar&amp;quot; );   // h1 elements that don&#39;t have a class of bar&#xA;$( &amp;quot;ul li&amp;quot; ).filter( &amp;quot;.current&amp;quot; ); // unordered list items with class of current&#xA;$( &amp;quot;ul li&amp;quot; ).first();  // just the first unordered list item&#xA;$( &amp;quot;ul li&amp;quot; ).eq( 5 );  // the sixth&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;选择Form表单元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;:checked&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以用于checkbox、radion buttons、selects，不要被checked迷惑&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;form :checked&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;:disabled&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用于所有disable属性&amp;rdquo;input&amp;rdquo;标签：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;form :disabled&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;:enabled&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用于选择所有非:disabled属性的元素：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$( &amp;quot;form :enabled&amp;quot; );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;为了更好的性能，可以使用.filter(&amp;rdquo;:enabled&amp;rdquo;)，或者用其他选择器或者用ID/tag name等选择&lt;/p&gt;&#xA;&#xA;&lt;p&gt;:input&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用于选择所有&amp;rdquo;input&amp;rdquo;、&amp;rdquo;textarea&amp;rdquo;、&amp;rdquo;select&amp;rdquo;、&amp;rdquo;button&amp;rdquo;元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;form :input&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;:selected&#xA;用于选择&lt;option&gt;中被选择的选项：&#xA;$( &amp;ldquo;form :selected&amp;rdquo; );&#xA;为了性能，可以用.filter(&amp;rdquo;:selected&amp;rdquo;)或者其他选择器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过类型选择&#xA;类型包括：&#xA;:password&#xA;:reset&#xA;:radio&#xA;:text&#xA;:submit&#xA;:checkbox&#xA;:button&#xA;:image&#xA;:file&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多详细内容见API：  &lt;a href=&#34;http://api.jquery.com/category/selectors/&#34;&gt;http://api.jquery.com/category/selectors/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用selections工作&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Getter 和 Setter&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Setter是作用于选中对象的所有元素，Getter是作用于选用对象的第一个元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// The .html() method used as a setter:&#xA;$( &amp;ldquo;h1&amp;rdquo; ).html( &amp;ldquo;hello world&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// The .html() method used as a getter:&#xA;$( &amp;ldquo;h1&amp;rdquo; ).html();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Setter是返回一个jQuery对象，所以允许你在你选中元素上继续调用jQuery的相关方法，而Getter返回的你请求获取的内容，所以不能继续对其调用jQuery方法：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Attempting to call a jQuery method after calling a getter.&#xA;// This will NOT work:&#xA;$( &amp;ldquo;h1&amp;rdquo; ).html().addClass( &amp;ldquo;test&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;链式调用：&#xA;选择一个元素返回的是一个jQuery对象，所以可以持续调用其方法：&#xA;$( &amp;ldquo;#content&amp;rdquo; ).find( &amp;ldquo;h3&amp;rdquo; ).eq( 2 ).html( &amp;ldquo;new text for the third h3!&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;等价于以下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;#content&amp;rdquo; )&#xA;.find( &amp;ldquo;h3&amp;rdquo; )&#xA;.eq( 2 )&#xA;.html( &amp;ldquo;new text for the third h3!&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.end()方法可以回到初始调用的选择节点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;#content&amp;rdquo; )&#xA;.find( &amp;ldquo;h3&amp;rdquo; )&#xA;.eq( 2 )&#xA;.html( &amp;ldquo;new text for the third h3!&amp;rdquo; )&#xA;.end() // Restores the selection to all h3s in #content&#xA;.eq( 0 )&#xA;.html( &amp;ldquo;new text for the first h3!&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;操作元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取/设置元素信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• .html() – Get or set the HTML contents.&#xA;• .text() – Get or set the text contents; HTML will be stripped.&#xA;• .attr() – Get or set the value of the provided attribute.&#xA;• .width() – Get or set the width in pixels of the first element in the selection as an integer.&#xA;• .height() – Get or set the height in pixels of the first element in the selection as an integer.&#xA;• .position() – Get an object with position information for the first element in the selection, relative to its first positioned ancestor. This is a getter only.&#xA;• .val() – Get or set the value of form elements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;移动、复制、删除元素&#xA;操作DOM大致分成两种情况：&#xA;1.将选择元素放置在某个元素的某个相对位置&#xA;2.将某个元素放置在选择元素的某个相对位置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery提供了.intertAfter()和.after()方法，.intertAfter()是通过将某个元素作为参数来达到将选择元素放在该元素之后，.after()是通过某个元素作为参数来达到将该元素放在选择元素之后的效果。同样的还有.insertBefor()和.before()，apptendTo()和append(),.prependTo()和pretend()。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Moving elements using different approaches.&#xA;// Make the first list item the last list item:&#xA;var li = $( &amp;ldquo;#myList li:first&amp;rdquo; ).appendTo( &amp;ldquo;#myList&amp;rdquo; );&#xA;// Another approach to the same problem:&#xA;$( &amp;ldquo;#myList&amp;rdquo; ).append( $( &amp;ldquo;#myList li:first&amp;rdquo; ) );&#xA;// Note that there&amp;rsquo;s no way to access the list item&#xA;// that we moved, as this returns the list itself.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;复制元素：&#xA;通过.clone()方法复制元素，例如复制同样一个元素加载li最后：&#xA;// Making a copy of an element.&#xA;// Copy the first list item to the end of the list:&#xA;$( &amp;ldquo;#myList li:first&amp;rdquo; ).clone().appendTo( &amp;ldquo;#myList&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;移除元素：&#xA;通过remove()和detach()两个方法移除，两者的不同是：&#xA;remove()是永久的删除该元素，并且返回该元素，但是不会返回该元素相关联的数据和事件，而detach()是返回删除元素以及该元素相关联的数据和时间，可以存储一遍后面使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果只是移除元素中的内容，可以使用.empty()方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建一个新元素：&#xA;jQuery提供了$()方法创建新元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Creating new elements from an HTML string.&#xA;$( &amp;ldquo;&lt;p&gt;This is a new paragraph&lt;/p&gt;&amp;rdquo; );&#xA;$( &amp;ldquo;&lt;li class=\&#34;new\&#34;&gt;new list item&lt;/li&gt;&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也可以这样：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Creating a new element with an attribute object.&#xA;$( &amp;ldquo;&lt;a/&gt;&amp;rdquo;, {&#xA;html: &amp;ldquo;This is a &lt;strong&gt;new&lt;/strong&gt; link&amp;rdquo;,&#xA;&amp;ldquo;class&amp;rdquo;: &amp;ldquo;new&amp;rdquo;,&#xA;href: &amp;ldquo;foo.html&amp;rdquo;&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要注意的是一般情况下属性是不用双引号，出发是reserved words，例如上面的class&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你创建一个元素不会立即增加到页面中，可以通过以下几种方式增加到页面中去：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Getting a new element on to the page.&#xA;var myNewElement = $( &amp;ldquo;&lt;p&gt;New element&lt;/p&gt;&amp;rdquo; );&#xA;myNewElement.appendTo( &amp;ldquo;#content&amp;rdquo; );&#xA;myNewElement.insertAfter( &amp;ldquo;ul:last&amp;rdquo; ); // This will remove the p from #content!&#xA;$( &amp;ldquo;ul&amp;rdquo; ).last().after( myNewElement.clone() ); // Clone the p so now we have two.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也可以不用将创建的元素报错在操作，可以直接操作：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Creating and adding an element to the page at the same time.&#xA;$( &amp;ldquo;ul&amp;rdquo; ).append( &amp;ldquo;&lt;li&gt;list item&lt;/li&gt;&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也可以用一个数组将元素保存，最后将数组放入一个字符串加入：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var myItems = [];&#xA;var myList = $( &amp;ldquo;#myList&amp;rdquo; );&#xA;for ( var i = 0; i &amp;lt; 100; i++ ) {&#xA;myItems.push( &amp;ldquo;&lt;li&gt;item &amp;ldquo; + i + &amp;ldquo;&lt;/li&gt;&amp;rdquo; );&#xA;}&#xA;myList.append( myItems.join( &amp;ldquo;&amp;rdquo; ) );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;操作元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Manipulating a single attribute.&#xA;$( &amp;ldquo;#myDiv a:first&amp;rdquo; ).attr( &amp;ldquo;href&amp;rdquo;, &amp;ldquo;newDestination.html&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Manipulating multiple attributes.&#xA;$( &amp;ldquo;#myDiv a:first&amp;rdquo; ).attr({&#xA;href: &amp;ldquo;newDestination.html&amp;rdquo;,&#xA;rel: &amp;ldquo;nofollow&amp;rdquo;&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Using a function to determine an attribute&amp;rsquo;s new value.&#xA;$( &amp;ldquo;#myDiv a:first&amp;rdquo; ).attr({&#xA;rel: &amp;ldquo;nofollow&amp;rdquo;,&#xA;href: function( idx, href ) {&#xA;return &amp;ldquo;/new/&amp;rdquo; + href;&#xA;}&#xA;});&#xA;$( &amp;ldquo;#myDiv a:first&amp;rdquo; ).attr( &amp;ldquo;href&amp;rdquo;, function( idx, href ) {&#xA;return &amp;ldquo;/new/&amp;rdquo; + href;&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The jQuery Object&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery Object相对于元素DOM元素的两大好处：&#xA;1.兼容性：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var target = document.getElementById( &amp;ldquo;target&amp;rdquo; );&#xA;target.innerHTML = &amp;ldquo;&lt;td&gt;Hello &lt;b&gt;World&lt;/b&gt;!&lt;/td&gt;&amp;rdquo;;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个在很多浏览器中是可以实现的，但是在大部分IE中是不支持的，但是通过将target元素包装成jQuery Object，就可以方便的通过如下代码在各个jQuery支持的浏览器中运行：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Setting the inner HTML with jQuery.&#xA;var target = document.getElementById( &amp;ldquo;target&amp;rdquo; );&#xA;$( target ).html( &amp;ldquo;&lt;td&gt;Hello &lt;b&gt;World&lt;/b&gt;!&lt;/td&gt;&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.方便性：&#xA;有时候操作原生的DOM方法也比较麻烦，例如新建一个元素newElement准备放在目标元素target之后，原生DOM方法操作如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Inserting a new element after another with the native DOM API.&#xA;var target = document.getElementById( &amp;ldquo;target&amp;rdquo; );&#xA;var newElement = document.createElement( &amp;ldquo;div&amp;rdquo; );&#xA;target.parentNode.insertBefore( newElement, target.nextSibling );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是通过将目标元素target保证成jQuery对象之后，就可以:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Inserting a new element after another with jQuery.&#xA;var target = document.getElementById( &amp;ldquo;target&amp;rdquo; );&#xA;var newElement = document.createElement( &amp;ldquo;div&amp;rdquo; );&#xA;$( target ).after( newElement );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获得jQuery对象中的元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当用CSS选择器的时候得到的jQuery对象包含所有符合条件的元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting all &lt;h1&gt; tags.&#xA;var headings = $( &amp;ldquo;h1&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;headings包含所有&lt;h1&gt;标签的元素，可以通过headings的.length属性验证：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Viewing the number of &lt;h1&gt; tags on the page.&#xA;var headings = $( &amp;ldquo;h1&amp;rdquo; );&#xA;alert( headings.length );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果目标是只要获取第一个&lt;h1&gt;标签的元素，可以通过.eq()方法:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting only the first &lt;h1&gt; element on the page (in a jQuery object)&#xA;var headings = $( &amp;ldquo;h1&amp;rdquo; );&#xA;var firstHeading = headings.eq( 0 );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;firstHeading是一个jQuery对象，可以使用.html()、.after()等方法，jQuery还提供了一个.get()方法，返回DOM元素，而不是jQuery包装的DOM元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting only the first &lt;h1&gt; element on the page.&#xA;var firstHeadingElem = $( &amp;ldquo;h1&amp;rdquo; ).get( 0 );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于jQuery对象是类似数组，以上代码等价于：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting only the first &lt;h1&gt; element on the page (alternate approach).&#xA;var firstHeadingElem = $( &amp;ldquo;h1&amp;rdquo; )[ 0 ];&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时firstHeadingElem是元素DOM元素，具有DOM元素的属性，例如innerHTML，和方法例如.appendChild()，但是没有jQuery对象的方法例如.html()和.after()。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery对象包装时确保了唯一，及时获取同一个元素的对象，两者===是不相等的：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Creating two jQuery objects for the same element.&#xA;var logo1 = $( &amp;ldquo;#logo&amp;rdquo; );&#xA;var logo2 = $( &amp;ldquo;#logo&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Comparing jQuery objects.&#xA;alert( $( &amp;ldquo;#logo&amp;rdquo; ) === $( &amp;ldquo;#logo&amp;rdquo; ) ); // alerts &amp;ldquo;false&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是.get()方法可以获取元素DOM元素，所以可以比较两个jQuery对象是否相等：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Comparing DOM elements.&#xA;var logo1 = $( &amp;ldquo;#logo&amp;rdquo; );&#xA;var logo1Elem = logo1.get( 0 );&#xA;var logo2 = $( &amp;ldquo;#logo&amp;rdquo; );&#xA;var logo2Elem = logo2.get( 0 );&#xA;alert( logo1Elem === logo2Elem ); // alerts &amp;ldquo;true&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Traversing&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多具体可见 &lt;a href=&#34;http://api.jquery.com/category/traversing/&#34;&gt;http://api.jquery.com/category/traversing/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Parents:&lt;/p&gt;&#xA;&#xA;&lt;div class=&#34;grandparent&#34;&gt;&#xA;    &lt;div class=&#34;parent&#34;&gt;&#xA;        &lt;div class=&#34;child&#34;&gt;&#xA;            &lt;span class=&#34;subchild&#34;&gt;&lt;/span&gt;&#xA;        &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div class=&#34;surrogateParent1&#34;&gt;&lt;/div&gt;&#xA;    &lt;div class=&#34;surrogateParent2&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;Parents:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting an element&amp;rsquo;s direct parent:&#xA;// returns [ div.child ]&#xA;$( &amp;ldquo;span.subchild&amp;rdquo; ).parent();&#xA;// Selecting all the parents of an element that match a given selector:&#xA;// returns [ div.parent ]&#xA;$( &amp;ldquo;span.subchild&amp;rdquo; ).parents( &amp;ldquo;div.parent&amp;rdquo; );&#xA;// returns [ div.child, div.parent, div.grandparent ]&#xA;$( &amp;ldquo;span.subchild&amp;rdquo; ).parents();&#xA;// Selecting all the parents of an element up to, but &lt;em&gt;not including&lt;/em&gt; the selector:&#xA;// returns [ div.child, div.parent ]&#xA;$( &amp;ldquo;span.subchild&amp;rdquo; ).parentsUntil( &amp;ldquo;div.grandparent&amp;rdquo; );&#xA;// Selecting the closest parent, note that only one parent will be selected&#xA;// and that the initial element itself is included in the search:&#xA;// returns [ div.child ]&#xA;$( &amp;ldquo;span.subchild&amp;rdquo; ).closest( &amp;ldquo;div&amp;rdquo; );&#xA;// returns [ div.child ] as the selector is also included in the search:&#xA;$( &amp;ldquo;div.child&amp;rdquo; ).closest( &amp;ldquo;div&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Children:&#xA;jQuery中获取子元素可以通过.children()和.find()方法，两者的不同是.children()获取直接子元素，.find()是可以递归获取所有子元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting an element&amp;rsquo;s direct children:&#xA;// returns [ div.parent, div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.grandparent&amp;rdquo; ).children( &amp;ldquo;div&amp;rdquo; );&#xA;// Finding all elements within a selection that match the selector:&#xA;// returns [ div.child, div.parent, div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.grandparent&amp;rdquo; ).find( &amp;ldquo;div&amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Siblings&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相邻子节点的获取有多个方法，.prev()是获取前一个元素，.next()是获取下一个元素，.siblings()是获取前后两个元素，还有.nextAll(), .nextUntil(), .prevAll(), .prevUntil()：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting a next sibling of the selectors:&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).next();&#xA;// Selecting a prev sibling of the selectors:&#xA;// returns [] as No sibling exists before div.parent&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).prev();&#xA;// Selecting all the next siblings of the selector:&#xA;// returns [ div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).nextAll();&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).nextAll().first();&#xA;// returns [ div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).nextAll().last();&#xA;// Selecting all the previous siblings of the selector:&#xA;// returns [ div.surrogateParent1, div.parent ]&#xA;$( &amp;ldquo;div.surrogateParent2&amp;rdquo; ).prevAll();&#xA;// returns [ div.surrogateParent1 ]&#xA;$( &amp;ldquo;div.surrogateParent2&amp;rdquo; ).prevAll().first();&#xA;// returns [ div.parent ]&#xA;$( &amp;ldquo;div.surrogateParent2&amp;rdquo; ).prevAll().last();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.siblings()获取所有相邻子元素：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Selecting an element&amp;rsquo;s siblings in both directions that matches the given selector:&#xA;// returns [ div.surrogateParent1, div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.parent&amp;rdquo; ).siblings();&#xA;// returns [ div.parent, div.surrogateParent2 ]&#xA;$( &amp;ldquo;div.surrogateParent1&amp;rdquo; ).siblings();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CSS, Styling, &amp;amp; Dimensions&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery中有方便的方法操作CSS元素的属性：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Getter：&#xA;// Getting CSS properties.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).css( &amp;ldquo;fontSize&amp;rdquo; ); // Returns a string such as &amp;ldquo;19px&amp;rdquo;.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).css( &amp;ldquo;font-size&amp;rdquo; ); // Also works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Setter：&#xA;// Setting CSS properties.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).css( &amp;ldquo;fontSize&amp;rdquo;, &amp;ldquo;100px&amp;rdquo; ); // Setting an individual property.&#xA;// Setting multiple properties.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).css({&#xA;fontSize: &amp;ldquo;100px&amp;rdquo;,&#xA;color: &amp;ldquo;red&amp;rdquo;&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CSS的属性在JavaScript中调用都是要通过将&amp;rsquo;-&amp;lsquo;修改成驼峰标识，例如CSS属性font-size在JavaScript中使用fontSize&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.css()是不稳定的，在生产中要尽量不用，而是将CSS规则放在class中然后通过改变元素的class属性达到效果：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Working with classes.&#xA;var h1 = $( &amp;ldquo;h1&amp;rdquo; );&#xA;h1.addClass( &amp;ldquo;big&amp;rdquo; );&#xA;h1.removeClass( &amp;ldquo;big&amp;rdquo; );&#xA;h1.toggleClass( &amp;ldquo;big&amp;rdquo; );&#xA;if ( h1.hasClass( &amp;ldquo;big&amp;rdquo; ) ) {&#xA;&amp;hellip;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;尺寸（Dimensions），具体可见API： &lt;a href=&#34;http://api.jquery.com/category/dimensions/&#34;&gt;http://api.jquery.com/category/dimensions/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Basic dimensions methods.&#xA;// Sets the width of all &lt;h1&gt; elements.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).width( &amp;ldquo;50px&amp;rdquo; );&#xA;// Gets the width of the first &lt;h1&gt; element.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).width();&#xA;// Sets the height of all &lt;h1&gt; elements.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).height( &amp;ldquo;50px&amp;rdquo; );&#xA;// Gets the height of the first &lt;h1&gt; element.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).height();&#xA;// Returns an object containing position information for&#xA;// the first &lt;h1&gt; relative to its &amp;ldquo;offset (positioned) parent&amp;rdquo;.&#xA;$( &amp;ldquo;h1&amp;rdquo; ).position();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Data Methods&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常用的元素操作时的数据操作方法，jQuery提供了直接的方法操作，而不用开发者关心内存问题：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Storing and retrieving data related to an element.&#xA;$( &amp;ldquo;#myDiv&amp;rdquo; ).data( &amp;ldquo;keyName&amp;rdquo;, { foo: &amp;ldquo;bar&amp;rdquo; } );&#xA;$( &amp;ldquo;#myDiv&amp;rdquo; ).data( &amp;ldquo;keyName&amp;rdquo; ); // Returns { foo: &amp;ldquo;bar&amp;rdquo; }&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Utility Methods&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在$命名空间中有一些实用的方法，具体可见API： &lt;a href=&#34;http://api.jquery.com/category/utilities/&#34;&gt;http://api.jquery.com/category/utilities/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.trim()：剔除字符串两头空白串&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Returns &amp;ldquo;lots of extra whitespace&amp;rdquo;&#xA;$.trim( &amp;ldquo;    lots of extra whitespace    &amp;rdquo; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each()：遍历数组或者对象&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each([ &amp;ldquo;foo&amp;rdquo;, &amp;ldquo;bar&amp;rdquo;, &amp;ldquo;baz&amp;rdquo; ], function( idx, val ) {&#xA;console.log( &amp;ldquo;element &amp;rdquo; + idx + &amp;ldquo; is &amp;rdquo; + val );&#xA;});&#xA;$.each({ foo: &amp;ldquo;bar&amp;rdquo;, baz: &amp;ldquo;bim&amp;rdquo; }, function( k, v ) {&#xA;console.log( k + &amp;ldquo; : &amp;ldquo; + v );&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each()可以在选择元素上被调用，遍历选中元素&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.inArray()：返回数组中值的索引值，如果没有返回-1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var myArray = [ 1, 2, 3, 5 ];&#xA;if ( $.inArray( 4, myArray ) !== -1 ) {&#xA;    console.log( &amp;ldquo;found it!&amp;rdquo; );&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.extend():用后续对象的属性替换第一个对象的属性：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var firstObject = { foo: &amp;ldquo;bar&amp;rdquo;, a: &amp;ldquo;b&amp;rdquo; };&#xA;var secondObject = { foo: &amp;ldquo;baz&amp;rdquo; };&#xA;var newObject = $.extend( firstObject, secondObject );&#xA;console.log( firstObject.foo ); // &amp;ldquo;baz&amp;rdquo;&#xA;console.log( newObject.foo ); // &amp;ldquo;baz&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果不想改变传进去的任何一个对象，可以在第一个参数传一个空对象：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var firstObject = { foo: &amp;ldquo;bar&amp;rdquo;, a: &amp;ldquo;b&amp;rdquo; };&#xA;var secondObject = { foo: &amp;ldquo;baz&amp;rdquo; };&#xA;var newObject = $.extend( {}, firstObject, secondObject );&#xA;console.log( firstObject.foo ); // &amp;ldquo;bar&amp;rdquo;&#xA;console.log( newObject.foo ); // &amp;ldquo;baz&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.proxy()：将作为参数传进来的函数中的this指向第二个传进来的参数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var myFunction = function() {&#xA;console.log( this );&#xA;};&#xA;var myObject = {&#xA;foo: &amp;ldquo;bar&amp;rdquo;&#xA;};&#xA;myFunction(); // window&#xA;var myProxyFunction = $.proxy( myFunction, myObject );&#xA;myProxyFunction(); // myObject&lt;/p&gt;&#xA;&#xA;&lt;p&gt;myObject作为第二个参数，被当作第一个参数myFunction函数中的this&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果有一个有方法的对象，可以传递该对象和对象方法的名称，那么方法的作用域还是在对象中：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var myObject = {&#xA;    myFn: function() {&#xA;        console.log( this );&#xA;    }&#xA;};&#xA;$( &amp;ldquo;#foo&amp;rdquo; ).click( myObject.myFn ); // HTMLElement #foo&#xA;$( &amp;ldquo;#foo&amp;rdquo; ).click( $.proxy( myObject, &amp;ldquo;myFn&amp;rdquo; ) ); // myObject&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Testing Type&#xA;测试类型typeof经常令人疑惑，所以jQuery提供了一些实用方法来代替：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.isArray([]); // true&#xA;$.isFunction(function() {}); // true&#xA;$.isNumeric(3.14); // true&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.type()检查创建值使用的内建类，这个是比typeof操作符更好的选择：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.type( true ); // &amp;ldquo;boolean&amp;rdquo;&#xA;$.type( 3 ); // &amp;ldquo;number&amp;rdquo;&#xA;$.type( &amp;ldquo;test&amp;rdquo; ); // &amp;ldquo;string&amp;rdquo;&#xA;$.type( function() {} ); // &amp;ldquo;function&amp;rdquo;&#xA;$.type( new Boolean() ); // &amp;ldquo;boolean&amp;rdquo;&#xA;$.type( new Number(3) ); // &amp;ldquo;number&amp;rdquo;&#xA;$.type( new String(&amp;lsquo;test&amp;rsquo;) ); // &amp;ldquo;string&amp;rdquo;&#xA;$.type( new Function() ); // &amp;ldquo;function&amp;rdquo;&#xA;$.type( [] ); // &amp;ldquo;array&amp;rdquo;&#xA;$.type( null ); // &amp;ldquo;null&amp;rdquo;&#xA;$.type( /test/ ); // &amp;ldquo;regexp&amp;rdquo;&#xA;$.type( new Date() ); // &amp;ldquo;date&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jQuery中的type可见： &lt;a href=&#34;http://api.jquery.com/jQuery.type/&#34;&gt;http://api.jquery.com/jQuery.type/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Iterating over jQuery and non-jQuery Objects&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each()是一个通用的遍历方法，遍历对象、数组、以及类数组的对象，空白对象通过命名属性遍历、数组和类数组对象通过索引：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var sum = 0;&#xA;var arr = [ 1, 2, 3, 4, 5 ];&lt;/p&gt;&#xA;&#xA;&lt;p&gt;for ( var i = 0, l = arr.length; i &amp;lt; l; i++ ) {&#xA;sum += arr[ i ];&#xA;}&#xA;console.log( sum ); // 15&lt;/p&gt;&#xA;&#xA;&lt;p&gt;等价于：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each( arr, function( index, value ){&#xA;sum += value;&#xA;});&#xA;console.log( sum ); // 15&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们不用通过arr[index]作为值传给$.each()的回调函数，另外：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var sum = 0;&#xA;var obj = {&#xA;foo: 1,&#xA;bar: 2&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;for (var item in obj) {&#xA;sum += obj[ item ];&#xA;}&#xA;console.log( sum ); // 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;等价于：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.each( obj, function( key, value ) {&#xA;sum += value;&#xA;});&#xA;console.log( sum ); // 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样，我们不用obj[key]来作为值传给$each()的回调函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：$.each()是给空白对象(plain objects)、数组(arrays)、类数组对象(array-like objects)而不是jQuery集合，以下是错误的：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Incorrect:&#xA;$.each( $( &amp;ldquo;p&amp;rdquo; ), function() {&#xA;// Do something&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.each()：是给jQuery集合用的，匹配元素后通过一个回调函数执行，该元素的索引和值都被当作回调函数的参数传入，回调函数执行时上下文是匹配的元素，所以回调函数中this关键字就是当前匹配的元素：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#&#34;&gt;Link 1&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#&#34;&gt;Link 2&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#&#34;&gt;Link 3&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;li&amp;rdquo; ).each( function( index, element ){&#xA;    console.log( $( this ).text() );&#xA;});&#xA;// Logs the following:&#xA;// Link 1&#xA;// Link 2&#xA;// Link 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然this是当前匹配的元素，那么为何回调函数中第二个参数也是当前匹配的元素？这是一个经常被问到的问题。&#xA;因为不断的用this经常会让人疑惑不易读，所以回调函数的第二个参数来处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;li&amp;rdquo; ).each( function( index, listItem ) {&#xA;    this === listItem; // true&#xA;    // For example only. You probably shouldn&amp;rsquo;t call $.ajax() in a loop.&#xA;    $.ajax({&#xA;        success: function( data ) {&#xA;        // The context has changed.&#xA;        // The &amp;ldquo;this&amp;rdquo; keyword no longer refers to listItem.&#xA;        this !== listItem; // true&#xA;        }&#xA;    });&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有时候.each()是不必要的：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;li&amp;rdquo; ).each( function( index, el ) {&#xA;$( el ).addClass( &amp;ldquo;newClass&amp;rdquo; );&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以用以下代码代替：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;li&amp;rdquo; ).addClass( &amp;ldquo;newClass&amp;rdquo; );&#xA;有时候一些方法不能遍历集合，这个时候在设置新值之前需要获取元素当前值时.each()就可以有用：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Doesn&amp;rsquo;t work:&#xA;$( &amp;ldquo;input&amp;rdquo; ).val( $( this ).val() + &amp;ldquo;%&amp;rdquo; );&#xA;// .val() does not change the execution context, so this === window&lt;/p&gt;&#xA;&#xA;&lt;p&gt;应该这样写：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;input&amp;rdquo; ).each( function( i, el ) {&#xA;var elem = $( el );&#xA;elem.val( elem.val() + &amp;ldquo;%&amp;rdquo; );&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下方法都需要.each()：&#xA;• .attr() (getter)&#xA;• .css() (getter)&#xA;• .data() (getter)&#xA;• .height() (getter)&#xA;• .html() (getter)&#xA;• .innerHeight()&#xA;• .innerWidth()&#xA;• .offset() (getter)&#xA;• .outerHeight()&#xA;• .outerWidth()&#xA;• .position()&#xA;• .prop() (getter)&#xA;• .scrollLeft() (getter)&#xA;• .scrollTop() (getter)&#xA;• .val() (getter)&#xA;• .width() (getter)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大多数情况，上面有getter标记的返回jQuery集合第一个元素的值而setter是对所有匹配的元素都有操作，需要注意的是.text()将会返回所有匹配元素的字符串拼接。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外设置值、属性等可以用匿名回调函数匹配元素，回调函数的参数是匹配元素的索引和getter方法的结果值，一下两个写法效果相同：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;input&amp;rdquo; ).each( function( i, el ) {&#xA;    var elem = $( el );&#xA;    elem.val( elem.val() + &amp;ldquo;%&amp;rdquo; );&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;input&amp;rdquo; ).val(function( index, value ) {&#xA;    return value + &amp;ldquo;%&amp;rdquo;;&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.map()&#xA;如果我们想将匹配的元素创建为一个数组或者连接字符串，此时用.map()：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var newArr = [];&#xA;$( &amp;ldquo;li&amp;rdquo; ).each( function() {&#xA;newArr.push( this.id );&#xA;});&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以这样做：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$( &amp;ldquo;li&amp;rdquo; ).map( function(index, element) {&#xA;return this.id;&#xA;}).get();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：.map()返回的是jQuery包装的集合对象，而.get()返回JavaScript原生的对象，如果想拼接字符串，可以用元素的JavaScript的.join()方法在get()之后调用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$.map&#xA;$.map()和.map()的区别于$.each()和.each()的区别类似，$.map()是作用于JavaScript的原生数组而.map()是作用于jQuery元素集合的。因为$.map()作用域JavaScript原生数组，所以返回的也是JavaScript原生数组，不需要通过.get()方法得到JavaScript原生数组，如果用了的话会报错。&#xA;需要注意的是$.map()的参数顺序有变化，第一个参数是value，第二个参数是index，这么做是因为本地的JavaScript的.map()方法需要可用(ECMAScript5标准)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;li id=&#34;a&#34;&gt;&lt;/li&gt;&#xA;&lt;li id=&#34;b&#34;&gt;&lt;/li&gt;&#xA;&lt;li id=&#34;c&#34;&gt;&lt;/li&gt;&#xA;&lt;script&gt;&#xA;var arr = [{&#xA;    id: &amp;ldquo;a&amp;rdquo;,&#xA;    tagName: &amp;ldquo;li&amp;rdquo;&#xA;}, {&#xA;    id: &amp;ldquo;b&amp;rdquo;,&#xA;    tagName: &amp;ldquo;li&amp;rdquo;&#xA;}, {&#xA;    id: &amp;ldquo;c&amp;rdquo;,&#xA;    tagName: &amp;ldquo;li&amp;rdquo;&#xA;}];&#xA;// Returns [ &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo; ]&#xA;$( &amp;ldquo;li&amp;rdquo; ).map( function( index, element ) {&#xA;    return element.id;&#xA;}).get();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Also returns [ &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo; ]&#xA;// Note that the value comes first with $.map&#xA;$.map( arr, function( value, index ) {&#xA;    return value.id;&#xA;});&#xA;&lt;/script&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Using jQuery’s .index() Function&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.index()无参数&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;div&gt;&lt;/div&gt;&#xA;&lt;li id=&#34;foo1&#34;&gt;foo&lt;/li&gt;&#xA;&lt;li id=&#34;bar1&#34;&gt;bar&lt;/li&gt;&#xA;&lt;li id=&#34;baz1&#34;&gt;baz&lt;/li&gt;&#xA;&lt;div&gt;&lt;/div&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;var foo = $( &amp;ldquo;#foo1&amp;rdquo; );&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + foo.index() ); // 1&#xA;var listItem = $( &amp;ldquo;li&amp;rdquo; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + listItem.index() ); // 1&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + listItem.first().index() ); // 1&#xA;var div = $( &amp;ldquo;div&amp;rdquo; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + div.index() ); // 0&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + div.first().index() ); // 0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.index()用string作为参数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;ul&gt;&#xA;&lt;div class=&#34;test&#34;&gt;&lt;/div&gt;&#xA;&lt;li id=&#34;foo1&#34;&gt;foo&lt;/li&gt;&#xA;&lt;li id=&#34;bar1&#34; class=&#34;test&#34;&gt;bar&lt;/li&gt;&#xA;&lt;li id=&#34;baz1&#34;&gt;baz&lt;/li&gt;&#xA;&lt;div class=&#34;test&#34;&gt;&lt;/div&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;last&#34;&gt;&lt;/div&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var foo = $( &amp;ldquo;li&amp;rdquo; );&#xA;// This implicitly calls .first()&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + foo.index( &amp;ldquo;li&amp;rdquo; ) ); // 0&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + foo.first().index( &amp;ldquo;li&amp;rdquo; ) ); // 0&#xA;var baz = $( &amp;ldquo;#baz1&amp;rdquo; );&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + baz.index( &amp;ldquo;li&amp;rdquo; )); // 2&#xA;var listItem = $( &amp;ldquo;#bar1&amp;rdquo; );&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + listItem.index( &amp;ldquo;.test&amp;rdquo; ) ); // 1&#xA;var div = $( &amp;ldquo;#last&amp;rdquo; );&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + div.index( &amp;ldquo;div&amp;rdquo; ) ); // 2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;.index()使用jQuery对象调用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;ul&gt;&#xA;&lt;div class=&#34;test&#34;&gt;&lt;/div&gt;&#xA;&lt;li id=&#34;foo1&#34;&gt;foo&lt;/li&gt;&#xA;&lt;li id=&#34;bar1&#34; class=&#34;test&#34;&gt;bar&lt;/li&gt;&#xA;&lt;li id=&#34;baz1&#34;&gt;baz&lt;/li&gt;&#xA;&lt;div class=&#34;test&#34;&gt;&lt;/div&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;last&#34;&gt;&lt;/div&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var foo = $( &amp;ldquo;li&amp;rdquo; );&#xA;var baz = $( &amp;ldquo;#baz1&amp;rdquo; );&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + foo.index( baz ) ); // 2&#xA;var tests = $( &amp;ldquo;.test&amp;rdquo; );&#xA;var bar = $( &amp;ldquo;#bar1&amp;rdquo; );&#xA;// Implicitly calls .first() on the argument.&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + tests.index( bar ) ); // 1&#xA;console.log( &amp;ldquo;Index: &amp;ldquo; + tests.index( bar.first() ) ); // 1&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>《把时间当作朋友》读书笔记（下）</title>
      <link>http://www.wowzai.com/2015/second-reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html</link>
      <pubDate>2015-04-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这是接上一篇《把时间当作朋友》读书笔记。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第4章：学习&#34; href=&#34;#第4章：学习&#34;&gt;&lt;/a&gt;第4章：学习&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.效率本质&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;因为有能力的人做更多的事情了，他也就不再存在于原本的世界里；因为所习得的技能让自己拥有了另外一个完全不同的世界。每掌握一项新的技能，就感觉自己像重生了一次。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了演员因为演的剧多了也就像经历了很多，重生了很多次。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;拒绝学习或者一不小心受了影响而把“学习”两个字妖魔化了的人真的非常可伶，他们每天都挣扎着要“管理时间”、“珍惜生命”、“提高效率”，却不知道他们因为当初不肯花十几分钟学习而导致其后少做了很多事情、错过了很多机会，并且连只有一次的人生都没有过好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;千万不要拒绝学习。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.基本途径&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;获取更多知识几乎是我们开拓自身心智的唯一手段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获取知识最基础的手段就是“体验”，比“体验”更高级一点的是“试错”，然后是“观察”，最后是“阅读”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了同学聚会，一个同学炒菜的例子，用手去试油温，然后另外一个同学“观察”出原来不能用手去试的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过阅读可以获取更多信息，举大众点评的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没有知识，精神怎么会自由呢？精神不自由，肉体自由又算什么？精神的自由谁也夺不走。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.主要手段&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;正确思考才是获取真正意义上的知识的主要手段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了达尔文的例子。学会了“结绳记事”成语。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;科学方法论。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开启心智，正确思考，更值得我们投入时间和精力。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.经验局限&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举了猴子被关在笼子里如果去拿香蕉就会被泼冷水，新来的猴子去拿香蕉就会被打，笼子里猴子全部换一遍后，每个新来的猴子如果拿香蕉就会被打，导致新来的猴子都不知道为什么不能拿香蕉只知道如果拿的话就会被打的故事。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;许多传统的形成与这个故事相同，所以我们需要经常思考。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 个体经验的局限性&lt;br /&gt;&#xA;    举了“强光喷嚏反射”、同性恋以及色盲的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 群体经验有限&lt;br /&gt;&#xA;    最主要的原因是人的寿命有限&lt;br /&gt;&#xA;    很多时候，人们的善良出于软弱，而他们的残暴只不过来自于恐惧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 不仅存在无法通过个体或者群体经验获得的知识，还存在于现有经验相悖的知识&lt;br /&gt;&#xA;    使用类比理解新知识的前提：这个新知识与某个“现存经验”接近或类似。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“沟通障碍”本质上几乎都是由于沟通双方无法让对方理解与他们现有经验相悖的知识或信息造成的。&lt;br /&gt;&#xA;“优秀的领导能够把人们带到他们想去的地方，而卓越的领导，能够把人们带到他们应该去但是没想过要去的地方”&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.自学能力&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;自学能力的基础是阅读理解能力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;检索能力建立在相当熟练的阅读理解能力的基础之上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;写作能力在自学能力中占据重要位置，写出简洁、有效、准确、朴素、具体的说明性和说理性文章的能力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;实践能力是自学能力最终转化为真正有价值的根本，要有搞清楚一切的心态。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;永远保持开放的心态，对抗“选择性输入”可以借助笔和纸&amp;mdash;-如果有条件的话，最好固定一段时间来吧暂时无法理解的、支持的、反对的、无所谓的观点记录下来，并记录原因和困惑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;了解学习的进程，学习的时候进展和时间的关系肯定不是线性的，学习就像华尔兹&amp;ndash;先进一步，再退两步。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wowzai/wowzai.github.com/blob/master/imags/3.png?raw=true&#34; alt=&#34;图3&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第5章：思考&#34; href=&#34;#第5章：思考&#34;&gt;&lt;/a&gt;第5章：思考&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.勤于思考&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;人都有大脑，限制还是使用是个问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;独立思考，只不过是从别人那里知道一个结论的时候，自己动脑重新推演一遍，看看得出结论的过程中有没有漏洞，有没有不合理的地方，衡量一下结论到底有多少道理的过程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举权威的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;罗素：“有些人宁愿死都不愿思考”&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.思维陷阱&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;导致人们犯逻辑错误最重要的原因有两个：概念不清和拒绝不确定性&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 概念不清&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;人们为了能够认知、思考、交流，必须不断地创造新的概念。有些概念一直沿用至今，有些可能被丢弃。人们不停地修改和增补一些概念，证伪和丢弃那些错误的、不必要的概念，就是为了能把这个世界看得更清楚。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习任何知识最重要的一点，就是搞清楚它所有的概念。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 拒绝接受不确定性&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;拒绝接受不确定性的一个根源在于害怕复杂、奢望简单。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.因果关系&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;人类的思考离不开因果关系的分析。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 基础&lt;/p&gt;&#xA;&#xA;&lt;p&gt;分析任何因果关系，比如针对“因为A，所以B”，基本只需要从3个层面去审视：&lt;br /&gt;&#xA;    1）A不一定是B的理由&lt;br /&gt;&#xA;    2）A不一定是B的唯一理由&lt;br /&gt;&#xA;    3）A不一定是B最重要的理由&lt;br /&gt;&#xA;举了“看电视破坏了人与人之间的沟通”的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外有时候，相关联的两者间是“互为因果”，举了“外因通过内因起作用，根本还是内因”，其实外因与内因互为因果。举了教师和学生的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要做一个有心的人，要用心做事，因为这世界其实也是有“心”的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 双盲测试&lt;/p&gt;&#xA;&#xA;&lt;p&gt;亨利·诺尔斯·比彻研究出“安慰剂效应”，既平均有35.2+/-2.2%的效果来自安慰剂。为了消除安慰剂效应的影响，鉴定医疗方法是否真正有效，进一步发明了“双盲测试”检验方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;研究人员会招募一群病人作为被测试者。被测试者分为两组，一组服用新药，一组服用看起来一模一样的安慰剂&amp;mdash;事实上，他都认为自己服用的是药物。&amp;mdash;此为“一盲”。不同于测试者，发放药物的工作人员只知道一定有安慰剂，但是也不知道手中哪些是新药，哪些是安慰剂。如果两组好转的比例相当，说明新药几乎是无用的，作用和安慰剂差不多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了“激光心肌血运重建书”的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 自证预言&lt;/p&gt;&#xA;&#xA;&lt;p&gt;罗伯特·莫顿发现这种现象，既如果人们相信某件事后发生，那么这件事最终真的会发生。&#xA;举了希腊神话中俄狄浦斯的弑父娶母、银行挤兑的故事。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从现在开始，在相当长的一段时间里，时时刻刻注意自己的或被灌输的每一个念头，甄别其中因果关系，逐一应用以上提到的种种原则。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.逆命题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;原命题为真，逆命题不一定为真，举了一个教GRE同事，同学说听不懂，这个同事反问你听得懂美国人说英语的例子。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.举证责任&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;甲：有人能活200岁以上&#xA;已：扯淡，我还真没见过活过200岁以上的。&#xA;甲：你没见过就没有吗？你必须找遍世界才能证明。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;甲下了个结论，甲有责任证明，而不是乙的责任。“谁主张谁举证”生活中方方面面都可以用到。由于举证难度不同，争论双方常常处于：&#xA;1）其中一方肩负沉重的举证责任&#xA;2）另外一方则享有来自假设的优惠&#xA;当有一方拒绝矩阵责任时讨论无法正常进行，应立即结束。既然你无法证明我是错的，那么我就是对的。这是一种典型逻辑错误。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;6.案例局限&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;哈佛商学院开创的“案例教学法”，没有更好的方法，我们要认识这种方法方法可能导致各种各样的逻辑错误，最常见是“以偏概全”，举了爱迪生的例子。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;7.对立论证&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举下属发现上司“愚蠢”的例子，人只有在做事的时候才会暴露缺点。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;8.张冠李戴&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;论点和论据之间毫无逻辑关系，却用一种“显然合理”的姿态绑在一起。举了牧师为了让孩子不吵把撕碎的地图拼起来，而孩子很快完成（根据背面的人像），所以得出一个人是正确的，那么他的世界就是正确的结论显然是不正确的。还举了Attitude单词按字母顺序每个字母相加等于100的例子（1+20+20+9+20+21+4+5）；&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;9.感悟与道理&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;反思能力是人类独有的能力之一，尽管如此，我们还常说“光想是没用的”，因为反思的结果并不一定有价值，很可能顶多是“感悟”，离“道理”还差十万八千里。举了母亲生小孩许多人给“建议”、“忠告”的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“道理”是普适的，“感悟”并不是普适的。举了成功者分享成功经验的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“遗忘痛苦”是人的一种自我保护功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“若是为了爱情，歌曲算个屁，若是为了生命，爱情算个屁”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与其关注成功者，不如努力从失败者身上汲取经验。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;10.克服恐惧&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;恐惧导致懦弱。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为害怕强者无疆而又不能面对自己的懦弱与无能，所以人们宁愿相信“恶有恶报，善有善报”。人人都有恐惧，恐惧需要克服，勇气需要培养。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不要以为自己拥有无比的勇气，不要以为自己没有恐惧，总会有那么一个时刻，我们的勇气不能抵御我们的恐惧。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;11.辅助工具&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;语言是表达我们的思维的工具，也会限制我们的思维。举了作者父亲禁止作者在任何情况下说类似这样的话：“……本来（原本）就是这样的嘛！”这实际上只有一个用处&amp;mdash;找（最后的）借口。&#xA;举电影中报社老板呵斥新记者永远不要说“我认为……”，你的看法关我屁事，我要的是事实。后来新记者每次都用“事实上”开头，而为了配上“事实上”会自动地过滤掉很多“偏见”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;作者总结有助于思考的句式：&lt;br /&gt;&#xA;“……是一回事，而……是另外一回事。”&lt;br /&gt;&#xA;“……和……其实根本不是一回事。”&lt;br /&gt;&#xA;“……不一定……”&lt;br /&gt;&#xA;“……。可是，这并不意味着……”&lt;br /&gt;&#xA;“……也许还有另外一种可能性（解释）”&lt;br /&gt;&#xA;“……看起来像……，可是……”&lt;br /&gt;&#xA;“……。而事实却可能远比看起来的更为复杂（简单）”&lt;br /&gt;&#xA;“……。然而，（这个论断）反过来（陈述）却不一定成立……”&lt;br /&gt;&#xA;“……其实很可能与……根本就没有任何关系，他们可能互为因果”&lt;br /&gt;&#xA;“……和……之间的比较也许没有任何意义。”&lt;br /&gt;&#xA;“……其实不过是表面现象，其背后的本质是……”&lt;br /&gt;&#xA;“……有一个通常被忽略的前提。”&lt;br /&gt;&#xA;“……尽管听起来很有道理，然而却完全不现实。”&lt;br /&gt;&#xA;“……也许有人会说……，但是这种质疑却……”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要回避的句式：&lt;br /&gt;&#xA;“……难道就没有可取之处嘛？” &amp;ndash;即使坏掉不走的表一天之中还能对两次。&lt;br /&gt;&#xA;“要是……就好了。”&amp;ndash;表达一种后悔情绪，根本于事无补。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第6章：交流&#34; href=&#34;#第6章：交流&#34;&gt;&lt;/a&gt;第6章：交流&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.学会倾听&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;人类讲话速度远低于思考的进度，倾听时第一次走神没关系，后面走神次数、时间就会越多越长。大脑有自动拼接的能力，将零散的信息按某种之前曾经遇到过的模式拼接起来。举了911事件“魔鬼面孔”的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不断地收集、整理、修正自己的判断类知识，就好像是为自己编织一张“滤网”，以组织无效的概念知识的进入。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;倾听过程中不要过早质疑，接受过程中理由剩余的脑力“回顾”和“预期”，如果是事实，想“陈述的内容的真实性”，如果是看法 ，想“看法/意见的根源在哪”&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.说与不说&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;通过努力、积累，成为能说更多话的人。&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;没有人一开始就拥有一切，生活中的绝大部分的东西，都要靠努力争取才能获得。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;尊重也只能靠积累获得，这是铁律。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“可与言而不与言，失人。不可与言而与之言，失言。”&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.共生状态&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;婴儿刚生下来觉得自己饿的时候全世界都是饿的，自己痛全世界都痛。心理学称这种状态为“共生”。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 第一个原则：有意义的讨论的前提是双方不仅要“相互竞争”，更要“相互合作”&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;对话原则：&lt;br /&gt;&#xA;    1）目的是寻求真理，而不是为了斗争&lt;br /&gt;&#xA;    2）不做人身攻击&lt;br /&gt;&#xA;    3）保持主题&lt;br /&gt;&#xA;    4）不要坚持错误不改&lt;br /&gt;&#xA;    5）要分清对话与只准自己讲话的区别&lt;br /&gt;&#xA;    6）对话要有记录&lt;br /&gt;&#xA;    7）尽量理解对方&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 第二个原则：真理是独立存在的，它从来不会依附于任何个人或集体存在&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;每个人生来都是以无知为起点，而成长之路原本就是求知之路。我们为了变得“有知”而挣扎；然而，挣扎的结果是我们将面临更多的“无知”。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 第三个原则：真理不变，也不会因为任何人而变；不停变换的只是对真理的解释或者理解&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;当有人以“每个人都（应当）有自己的看法，不是吗？”来维护自己“看法”的时候，就应该停止讨论，因为接下来的讨论都是没有任何意义的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.正确复述&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在沟通过程中，当我们听对方说完之后，应该自觉避免自以为是地认为自己肯定理解对了，可以用以下句式：“你的意思是……，对吗？”或者“你的意思是……，我理解的对吗？”。（已掌握）&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.勤于思考&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;我们的视觉、嗅觉、味觉、触觉都可能不可靠。www.brainbasher.com网站上有许多图片可以证明我们的视觉会出错。每个人都可能“只看到部分事实”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 深刻理解经验的局限&lt;br /&gt;&#xA;摆脱经验主义的第一个技巧就是“了解经验的局限”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 时时刻刻保持警惕&lt;br /&gt;&#xA;经验需要归纳，更需要经过演绎来论证。归纳耗时长，演绎论证来的经验可能耗时更长。所以在使用这些未经过演绎论证的经验可能存在风险。实际上“确定”常常是永远做不到的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 使用记录，使自己能够记住更多的经验&lt;br /&gt;&#xA;举作者自己26岁习得做记录的方法和习惯，收益颇多，依靠记录避免了很多次犯同样错误的危险（但是也不可能完全避免）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 通过观察和阅读汲取他人的经验&lt;br /&gt;&#xA;观察和阅读，是扩充有限的自我经验的最好手段。每个人每时每刻都有观察的机会，只需多琢磨一下“他们为什么这么想”；“他们为什么这么做”，“他们为什么那么看”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 经常试用类比来跨越未知与已知的障碍&lt;br /&gt;&#xA;举了“原子内部结构与太阳系差不多”的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• 耐心等待以获得不能跨越时间的经验&lt;br /&gt;&#xA;遇到不理解的问题，遇到不确定的想法，最好马上记录下来，不一定非要急着获得答案。又举了怀孕至少也要40周才能生下来的例子。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第7章：应用&#34; href=&#34;#第7章：应用&#34;&gt;&lt;/a&gt;第7章：应用&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.兴趣&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;人们往往并不是有了兴趣才能做好，而是做好了才有兴趣，人们往往搞错顺序。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.方法&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举了作者父亲学习外语、钟道隆先生的“逆向法”、李阳“疯狂英语”、俞敏洪的例子，作者健身教练练臂围的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习上的成功，都只依靠两件事&amp;mdash;策略和坚持。而坚持本身就是最重要的策略。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.痛苦&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于痛苦的深刻感受，会扭曲或者抹杀人们感知其他食物的能力。最常见的误解就是：当我们觉得痛苦的时候，总是不自觉地把自己想象成全世界最痛苦的人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果明白自己所面临的痛苦其实很并没有自己感受的那么强烈，我们就很容易&amp;mdash;-起码比较容易忍受那些痛苦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了林肯和一个14岁小孩的例子，提醒自己所经历的痛苦并不是那么的痛苦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学会运用心智的力量把自己的注意力转移到其他地方，痛苦就几近消失。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大脑有遗忘痛苦的自我保护机制。举了被截肢者18个月后基本不会自杀的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为减少“反复犯以往同样的错误”：&#xA;1）在面临尴尬时，用文字、图画等形式记录下来，最好是同一个地方，并且定期回顾&#xA;2）在面临尴尬时，弱化痛苦，控制自己的情绪，不要被大脑直接反应所左右。&#xA;举了朋友背单词算钱的例子。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.比较&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;生活无法彻底回避比较，但是生活中也有很多快乐和幸福无须比较。比成功更重要的是成长。如果“成功”是与他人比较的话，那么“成长”则是与自己比较&amp;mdash;今天的我和昨天的我，明天的我和今天的我。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;常常问自己一些这样的问题：“我做完这件事情之后获得的快乐和幸福是不是一定要建立在比较的基础上？”想清楚之后，标记并优先实施那些无须比较就可以获得快乐和幸福的行动方案。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.运气&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举了同样买彩票的张三（买一张中）和李四（买非中号码以外所有彩票）的例子，为什么相同概率，而两个人感觉天差地别？概率是一样的，不一样的是人的欲望。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信运气其实是缺乏自制力的表现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果一个人面对现有的尴尬，不愿意承担责任，最方便的做法就是去抱怨坏运气。机会时时刻刻都会出现在我们身边，关键在于我们有没有足够努力，做到“万事俱备，只欠东风”。而当一个人准备好了，随处都是机会，而且所有的机会都是切实可行的，可以把握的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;6.人脉&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;专心打造自己，让自己成为一个优秀的人，一个有用的人、一个独立的人，比什么都重要。&lt;br /&gt;&#xA;1）专心做可以提升自己的事情，学习并拥有更多更好的技能，成为一个值得他人交往的人&lt;br /&gt;&#xA;2）学会独善其身，以不给别人制造麻烦为关键，用自己的独立赢得尊重。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;7.自卑&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;最佳：愿望中的自己=真实的自己=感觉中的自己&lt;br /&gt;&#xA;通常：愿望中的自己≠真实的自己≠感觉中的自己&lt;/p&gt;&#xA;&#xA;&lt;p&gt;停止嘲弄他人，嘲弄他人无非是想证明自己“强”，而真正的“强”是不需要证明的，需要证明的“强”其实是清楚自证的“弱”。生活中，很少遇到他人的“弱”影响到我们的“强”的情况。（想一想哪些会影响？）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举作者自己大学宿舍扒裤衩的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;三个方法：&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;1）忘记自己的优点&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;2）在自己的语言里，把“优点”和“缺点”改成“特点”&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;3）适当放纵下自己&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;8.灵感&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举了作者平时积累被社会遗忘的重要人物的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;灵感这东西，就算存在，也不会是平白无故的出现，肯定是有来历的。灵感的出现，只不过是“量变到质变”的那一瞬间突然绽放的铁树之花。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了李敖读书方法的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有的成功，本质上都是一样的。先花上相当的时间和精力去锁定一个方向或者目标。确定它现实可行之后，运用心智的力量，在这个方向上投入更多的时间，比更多再多一点的时间。把时间当朋友，一路前行。当时间陪伴你足够久的时候，它自己给你的耐心相应的回报。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;9.鼓励&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;尽量坚持一个原则：永远鼓励身边的人，哪怕多少有些盲目。（我自己做的不好）举了自己从小就视为异类的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大多数人以“泼冷水”为乐的。他们原本跟我一样&amp;mdash;他们也“跟大多数人不一样”。鼓励身边的人，哪怕他并不是我的朋友。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;10.效率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;每个人的能力、效率都存在一个上限。举了柳比歇夫的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;纯时间比毛时间少得多。所谓毛时间，就是你花在这项工作上的时间。&#xA;&#xA;常常人说，他们一天工作14、5个小时。这样的人可能真的有，可是拿纯时间来说的话，我一天干不了那么多。我做学术工作的时间，&#xA;最高纪录是11个小时30分。一般，我能有7、8个小时的纯工作时间我就心满意足了。我最高纪录的一个月是1937年7月，我一个月&#xA;工作了316个小时，每日平均纯工作时间7小时。如果估算折算成毛时间，应该增加25%到30%；我逐渐改变我的统计，最后形成了我&#xA;现在的方法。&#xA;&#xA;当然，每个人每天都需睡觉，都要吃饭。换句话说，每个人都有一定的时间用在标准活动上。工作经验表明，约有12到13个小时可以&#xA;用于非标准活动，诸如上班办公、学术工作、社会工作、娱乐等等。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;所以做时间预算，一定要预留空间。一方面，留出时间处理意外事件；另一方面，我们必须使用适当的方法休息、放松，以便恢复精力，在良好的状态下做更多的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看看自己做得事情中，有多少是尽管无趣却非常重要的，有多少是非常有趣却不重要的。要成为大脑的主人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;按照黄金分割法，不要把目标定的太高（100分），只要61.8分即可。因为超过61.8分就需要付出相当的努力。这样才不容易半途而废。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;罗列一下尽管无趣但实际上却非常重要的事情。挑一件认为最重要的事情，列出时间表，每天至少专注这件事情2个小时。最初可以采用20分钟休息5分钟的策略。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;11.节奏&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;应该把自己的生活节奏调整的慢一点。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举作者得脂肪肝后决定健身，并发现健身房商业模式，那些无法坚持的人很多是因为计划实际上是“超人计划”&amp;ndash;根本完成不了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正确的策略应该是：想办法提前预知自己需要掌握哪些技能，再确定他们是自己可以通过练习真正熟练掌握的技能，而后制定长期计划，一点一点稳步执行。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;12.物极必反&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;• 绝对不要减少睡眠时间&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;每个人睡眠时间不一样，接受现实。作者举了自己的解决方案：夜间睡眠4个小时，中午睡30分钟，下午6点左右睡30分钟&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 尽量不要减少与家庭成员交流的时间&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;对于大部分人，家庭最重要。随手记录与家庭成员通话的日期和时间，可以利用碎片时间打电话，假期尽量聚聚。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;• 最好不要放弃你的社交时间&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;大部分人都有依赖别人的时候，学会不停地帮助身边的人，并不一定是金钱帮助。运用自己的资源，为值得帮助的人提供帮助。列出值得自己帮助的人的特征，看看自己是否满足这些特征？如不满足，应该想办法改进。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提高自己的社交质量，最好将时间和精力更多地倾注在“把自己变得更加优秀”这件事情上。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;13.自我证明&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;“证明自己”本身并没有任何错误，但很多人实际上是挣扎着想“证明自己给别人看”&amp;mdash;这是一种浪费生命的行为。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你比别人强一点根本没用，真正有用的是你比别人抢很多很多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;长久地观察和思考，有益于锻炼自己心气平和的能力，反正别人如何认为、如何评价，如何一轮根本没办法影响一个人所处的状态。但是，一旦一个人开始为此心烦意乱、坐卧不安，甚至为此做出一些无聊的举动，那么他就不仅倒霉，而且是可怜了，因为他已经被别人左右了。被别人左右，是一个人相当可悲的状态之一。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;从容接受不能改变的，&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;敢于改变可以改变的，&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;有智慧分辨二者区别。&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;举“复利”的力量：&lt;br /&gt;&#xA;S = P * （1 + i）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;习惯决定命运，习惯就是“复利”，千万不要养成坏习惯，“怕麻烦”就是害死人的坏习惯，“怕麻烦”的利息很低，但是是“利滚利”。不要和“怕麻烦”的人在一起，要养成不怕麻烦的性格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;积累不只限于一代人的努力，积累的信念甚至可能遗传。耐心的父母更容易培养出耐心的孩子，相信积累的父母更容易培养出相信积累的孩子。举了心理学家马克·罗森茨威格分成三组养老鼠的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信积累的人更容易获得财富和成就。林肯说过：“男人要为自己40岁后的长相负责。”过了一定岁数之后，长相并不重要了。表情和神态是一个人内心的折射，几十年积累足以使一个人的内心变得“不俗”，于是，表情也跟着“从容”，神态也跟着“睿智”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果觉得积累已经来不及了，那就接受现实吧！想想看什么可以改变，什么不可以改变，找到能改变的领域，采取积累的策略，这是唯一的方法。每个人都需要为自己的过去负责埋单。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;别再跟时间较劲了，看清楚、想明白，问题出在自己身上。将来，时间可能是我们的敌人，也可能是我们的朋友。时间究竟是敌是友，就看你了……&lt;/h4&gt;&#xA;</description>
    </item>
    <item>
      <title>《把时间当作朋友》读书笔记（上）</title>
      <link>http://www.wowzai.com/2015/reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html</link>
      <pubDate>2015-04-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;李笑来老师的《把时间当作朋友》实在是一本太好的书，我已经是第二遍阅读，时读时新，这一次阅读有了更多的体会，也做了大量的读书笔记，分成两部分，今天是上半部分。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第0章：困境&#34; href=&#34;#第0章：困境&#34;&gt;&lt;/a&gt;第0章：困境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;举了生活中看书时候经常搞其他事情的例子，我们无法管理时间，我们真正能够管理的只有我们自己。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第1章：醒悟&#34; href=&#34;#第1章：醒悟&#34;&gt;&lt;/a&gt;第1章：醒悟&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;人们很难接受与自己已有知识和经验相左的信息或观念。因为一个人已有的知识和观念都是经过反复筛选的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wowzai/wowzai.github.com/blob/master/imags/1.png?raw=true&#34; alt=&#34;图1&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个道理明明非常正确，却因为讲述道理的人由于某件事被戳穿，露出伪君子的嘴脸，而使很多人不再相信那个原本应该被笃信的道理。“做事只要踏实，认真就会做大”，这原本是正确的，可是从唐骏说出来，很多人“开窍了”&amp;mdash;&amp;gt;再也不相信这种鬼话了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举作者自己学会盲打的例子，其实我们很多时候可以学会很多，只是我们自己限制了自己。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第2章：现实&#34; href=&#34;#第2章：现实&#34;&gt;&lt;/a&gt;第2章：现实&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.速成绝无可能&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;希望自己的愿望马上得到满足是每个人的天性，而且整个社会都在刺激人们发挥这种天性。&#xA;很多人不能真正地懂得“有些阶段就是无法跨越”，人们不切实际希望找到一个方法，迅速完成目标，获得解脱。可是无论什么都需要时间，而且可能需要很多时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人们生活满意度调查：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/wowzai/wowzai.github.com/blob/master/imags/2.png?raw=true&#34; alt=&#34;图2&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个人从15到45岁是一个持续下降的过程，在这30年里，有自我满意度持续下降所造成的浮躁形成了巨大的压力，越浮躁就越是对自己的现状不满，越是不满就越是浮躁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一方面是自己的欲望无限，另一方面是要完成的事情太多，一方面是自我满意度的不断下降&amp;ndash;这就是人们总是不由自主地期望速成。出路肯定存在，但这出路只有一个起点&amp;mdash;&amp;ndash;接受现实。告诉自己：我有不足，我需要时间改进，我没办法一蹴而就。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.交换才是硬道理&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;速成不可能，拿该怎么办？答案是换。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不成熟的人通常就是整天在想“我要。。。”，全然不顾自己其实一无所有。&#xA;没个人最初都是一无所有，然后通过各种手段&amp;mdash;努力、投机、勤奋、取巧，换取能够拥有的东西，而有的人连投机取巧都不会，致使长期以来得到的东西越来越少，积累聊胜于无。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“我要。。。”的欲望不断增加，大多数人都会浮躁，因为他们一无积累，二无方法和经验，更恶劣的时候欲望之火可以耗费他们所有的时间和精力，以致占用原本可以努力或投机的时间，陷入死循环，无法挣脱。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;积累多的人之所以“稳健”，因为对他来说，“我要”的欲望可以用“我有”的东西来满足。即便“我有”暂时不够，也能借助已经拥有的和足够的努力和勤奋，只需假以时日，定能如愿以偿。一旦得偿所愿，“我有”更多，“我要”的也更容易获得，如此形成良性循环。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;摆脱死循环的方法只有一个&amp;ndash;给我什么我就用好什么，积累到一定程度再去换能换的东西。要不断运用心智的力量去识别那些些死循环和恶性循环，然后在好像不可能的情况下跳出来。出者存，困者死。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.完美永远不存在&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;不要拿“做不好的事情我不做”来当借口。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.未知永远存在&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;为了进步，我们必须忍受一定的未知。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;焦虑是导致时间浪费、效率底下的根源之一。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.现状无法马上摆脱&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;无论是谁，进入自己梦想职业的成本都很高昂。接受现状对于大部分人才是最优策略&amp;ndash;有什么用什么，用什么都用好。不要常常觉得苦，而要想办法在任何情况下找到乐趣&amp;mdash;快乐是一种本事。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;6.把时间当朋友&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;几乎一切愚蠢的行为都来自否定现实、逃避现实。只有接受现实，才可能脚踏实地，避免心浮气躁，好高骛远。用正确地方法做正确的事情，并在最后期限之前漂亮地完成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正视“稀缺资源”，哪里都会有这个问题，而且几乎无解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;时间是现实的人的朋友，是不现实的人的敌人。时间不是故意这样做，只不过事实如此。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;第3章：管理&#34; href=&#34;#第3章：管理&#34;&gt;&lt;/a&gt;第3章：管理&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;1.估算时间&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;错误估算任务所需时间是最常见也是最致命的错误。侯世达法则：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;完成一个任务实际花费的时间总会超过计划花费时间，就算制定计划时考虑过本法则，也不可避免这种情况的发生。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;真实情况：学习A发现依赖B&amp;ndash;&amp;gt;学习B，发现依赖B&amp;ndash;&amp;gt;学习B，发现依赖C&amp;ndash;&amp;gt;。。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开始之前的重要步骤：分辨任务是熟悉的还是陌生的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2.及时行动&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;只要做事，就一定出现问题，这是现实。事情越有价值，困难就越具规模。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;没必要在意他人的非建设性的负面评价。在起步晚的情况下，问题不是“到时候能不能做好”，而是“到时候能做多好就做多好，总比什么都不做好”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;遇到什么任务，永远不要问“什么时候开始才好”，因为答案只有一个&amp;ndash;“现在”！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3.直面困难&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;效率低下的根本原因是什么？答案是：回避困难。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举了表面看起来十分努力但并非真的努力的例子。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;4.关注步骤&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;做任何事之前都要考虑三个方面：内容（what）、原因（why）、方法（how）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;思考方法需要从领悟内容入手，不停地细分、拆解任务，而且越具体越好，直至每个小任务都可以有一个人独立完成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;每个人都应该学习项目管理的经典书籍&amp;ndash;学会拆解任务。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;5.串行并行&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;生活中学会问自己这个道理还可以应用在哪方面，提高自己举一反三的能力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;并行可以提高效率，但前提是同时进行的两个任务都有足够了解。&amp;ndash;主动并行&lt;/p&gt;&#xA;&#xA;&lt;p&gt;被别人打扰，是被动并行&amp;mdash;效率低下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举华罗庚烧水泡茶的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举自己健身教练的例子，作者约3点到4点半，结果4点才到，练到4点半教练通知下课，却按照1个半小时收费，看上去“不通情理”，却无可挑剔。这种可以有效减少一种烦恼&amp;ndash;因其他人的错误而耽误自己时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要养成精细拆分任务的习惯，效率会提升。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;6.感知时间&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举柳比歇夫的例子（奇特的一生）&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;事件&amp;mdash;时间  记录日志&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;举例记账对于理财的重要性，但是因为麻烦很多人坚持不下来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然管理时间是不可能的，想尽一切办法真正了解自己、真正了解时间、精确感知时间，以后再想办法使自己以及自己的行为与时间“合拍”。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;7.记录开销&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;1&amp;gt;回忆昨天、前天、大前天的事件-时间&#xA;2&amp;gt;回忆上周、上月、上季的事件&amp;ndash;时间&#xA;3&amp;gt;每天回忆并记录&lt;/p&gt;&#xA;&#xA;&lt;p&gt;养成每天记录刚做完的事情&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;8.制定预算&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;养成每天记录时间开销之后，每天制作时间预算，制作计划，列出要做的事情，打上重要、一般、不重要的标签，困难：有些是“显得重要”，有些是“显得不重要”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最开始，可以只区分“重要”和“不重要”&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;9.计划&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;我们不是计划着失败，而是失败地计划&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1&amp;gt;计划成功前提：目标现实可行，举了有同学用半年时间出国的例子&#xA;对于大部分人，证明目标切实可行的方法：&#xA;   * 有人已经做到&#xA;   * 我和那个人无太大差距&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2&amp;gt;长期计划需要通过实践才能习得的能力&#xA;在目标显示可行、方向确定的情况，辅以计划才能成功。一般来讲，期限越短，内容越清晰，目标越容易实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;做长期计划显然是正确且必需的，但并非每个人都有长期计划的能力。这种能力可跻身最重要的能力之位，拥有它需要挣扎、努力，从一点一滴做起。不要一上来就指定过长的计划，哪怕是一个星期的计划，都不是很容易的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有些时候没必要做计划，缺少行动的计划毫无意义：&#xA;  * 任务非常简单&#xA;  * 初始状态下，我们往往并没有能力制定有效的计划&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;10.列表&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;举自己去超市买东西的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最方便的列表工具是笔和纸，只要自己看懂即可，需要随手可及，最重要的任务只有一个&amp;mdash;真正对目标的实现有帮助的任务。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;制作专门的下一阶段的任务列表，如果有新想法，放在下一个新的列表，不要动现有的列表。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一无事成最根本原因是放弃，方法有很多种，最常见是“换一个更好的方向”，所以指定好列表后，一定执行到底。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;墨菲定律：&lt;br /&gt;&#xA;    • 任何事情都没有表面看起来那么简单&lt;br /&gt;&#xA;    • 任何事情都会比你预计的时间长&lt;br /&gt;&#xA;    • 觉得会出错的地方总会出错&lt;br /&gt;&#xA;    • 如果担心某种事情发生，那么它就更有可能发生&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;11.流程&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;加快之星重复性任务速度，只需在遇到重复性任务时将其做完一次，然后马上总结、整理，搞清流程，再靠进一步的实践把他变成“闭着眼睛都能做的事情”。这是提高效率，减少失误的根本手段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举打电话的例子：&lt;br /&gt;&#xA;    • 打电话时间&lt;br /&gt;&#xA;    • 打电话前需要准备要点，最好记下了&lt;br /&gt;&#xA;    • 对方没接后，自己忘掉&lt;br /&gt;&#xA;    • 不要立即切入正题，先让对方知道自己是谁&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;12.预演&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;完事皆可准备，皆须提前准备。经过多次预演，才能更好地完成任务。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举自己上课的“课前恐惧症”，不能克服恐惧，仅仅做到习惯恐惧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举“年科同志”被追杀的经历的例子，演练的重要性。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;13.验收&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;很多人做事半途而废的原因在于从未想过要给自己执行任务时的表现设计一个验收机制。举了考试的例子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不管遇到什么任务，都应该对其认真审视，同时向自己提出一个问题并想办法回答清楚：“怎样才算做好”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果拆分多个子任务，那么确定“做好”的标准可能更容易一些。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了验收机制落到实处，我们应该在做一件事之前，拿出纸和笔写下每一个预定的验收标准。指定标准时不要选择做那种脆弱又不现实的“完美主义者”，而完全没有标准显然是愚蠢的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>我的生活由你负责</title>
      <link>http://www.wowzai.com/2015/my-life-is-your-responsibility.html</link>
      <pubDate>2015-03-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;生活中有很多问题，很多问题都是因为钱的问题引起的，钱是很多直接的导火索，但是大部分情况只是我们心智不够而已，这真是一个悲伤的故事。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;14年的开头，那是我还住在盛元慧谷，小区中就有一个飞马健身，那时我觉得需要为健身付出一点，因为身体才是革命的本钱，这个大家都知道，所以我去健身房办了两张健身卡，我天真的以为有了健身卡，我们会过上规律的运动生活，但是才办的时候，我去的还比较勤快，基本能保证一个星期4次，过完年，一个星期就能去一两次，到4月份，基本上就是不去的节奏，那时候还自我安慰道工作太忙，人真是一个善于自我欺骗的动物。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;经过14年不那么炎热的夏天，转眼即到了秋末，秋末的时候我在网上看到了许多MOOC的内容，遂决定加入MOOCer的大军中，刚开始我按照进度一步步来，那种感觉可以用飘飘然形容啊，觉得这下准没跑了，一定会如期完成，自己也会有一个大的提升，但是结果却与年初的健身卡一样无疾而终。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个中原因自然会有，当人想办一件事情的时候总是会找到支持干这件事的理由，半途反悔的时候同样也能找到反悔的理由。我一边喊着工作忙没时间健身，没时间MOOC，但是一边却追完《纸牌屋》、《追踪者》、《蝎子网络》、《基本演绎法》、《二炮手》、《武媚娘》、《风中奇缘》，还有一些我都不记得，追了一半没看的，还有什么《罗辑思维》、《晓说》等，所以14年经过这两件事情，让我知道了我自己的自我欺骗能力是有多么的强大，也意识到人的诡异。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;经过14年的这几件事情，让我更加地清楚认识自己，在指定15年计划的时候也更加务实，同时为提高自己做一些技术上的调整。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先在15年，年初我给自己写了一份简历，发现写简历的时候根本没什么可写的，但是我还是硬着头皮写了下来，并且要每三个月更新一次，将这三个月的成长补充进简历，同时也起到督促自己的作用，同时如果没有什么可以补充的说明这三个月没干什么帮助成长的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其次，在15年，我要更加的频繁的记录，尤其是自己的想法，自己做的事情，自己未完成的事情，与简历一样，没三个月梳理一次。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大的计划一定要分阶段，建立里程碑事件，细化到可以执行的粒度，不要再粗粗地定一个框架这种无法判断完成度的计划，以可以量化为标准。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人的意志力其实的有限的，这个其实和精力有关，如果一个精力旺盛的人他的有效时间一定比一个精力相对不那么旺盛的人要更多更有质量。在15年需要更合理的分配精力，充分利用时间，在效率较高的时候去做需要大量动脑的事情，例如学习，编程，计划等，利用效率较低的时间去做一些不那么耗精力的事情，例如和家人的沟通，人文书籍的阅读等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人的身体健康情况的重要性在过去的一年中有了更加深刻的理解。很多时候人不是故意不配合、摆脸色或者闹情绪，其实是精力不够的一种表现，没那么多的精力所以才会不耐烦，所以在15年，真真正正地把锻炼身体日常化，当成生活的一部分，只有身体更加健康，才会有更多的精力干更多地事情，长远来看我自己本人以及我的家人也会从中受益更多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2014年真正地想通两个非常重要的事情，一个是历史的车轮滚滚向前，二是健康的身体是万物之源。两个很正确的道理，说出去大家都会同意，但是要真正地领悟还真不是一朝一夕就可以。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我的生活，你应该来负责，才是不幸的根源，希望每个人都能对自己负责。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>年终总结</title>
      <link>http://www.wowzai.com/2015/summary-2014.html</link>
      <pubDate>2015-02-07 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;真正的总结&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;之前在空间里写了一个总结，只有几句话，只是表达个意思罢了，没有任何实质内容，年关将近，老婆已经回家了，今天一个人在家，想了很多，现在在这里再总结一次。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2014年的开头我已经记得不太清楚了，那个时候年末，估计还是在不停地加班并且准备一些结婚的事宜，我的记忆差不多从春节开始。关于春节，长大的春节已经没有小时候那么的兴奋了，好像过年似乎只剩下“赌博”。接下来就是结婚，婚礼其实是一件比较麻烦的事情，因为婚礼在老家办再加上天气不好，所以更加的不方便，结婚的那天我由于喝多了，晚上吐了很多，很多事情都不记得了，早上起来看到妹妹录影，简直不敢相信那是我，哎，所以下定决心以后不能喝醉。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;结婚完之后就开始正常的上班，有点小意外的是年后又发了一点年终奖，虽然只有几千块但是还是蛮意外的，不过对于加薪幅度我不是很满意，再加上工作内容非常多，干的事情有多又杂，后来就跟老大提了一次加薪的事情，老大说会帮我申请。后来在年中加薪的时候，加了一点，然后给我提了一级，但是说实话我还是不满意，但是我没有再提，这是后话。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后再是董飞飞从武汉来杭州，飞飞从一号店出来，跟着原来的老大加入创业公司，一个做租车服务的平台，但是因为种种原因一直没能和飞飞见一面吃一顿，还是蛮遗憾的，知道夏天我们才第一次在杭州见面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;工作上，开始做一些更大的设计工作，股转新三板是第一个负责设计全新模块，虽然股转新三板和原来股票的模块差不多，但是因为我是第一次做这样一个整块新业务的设计工作，所以还是很细心负责的去做，丝毫不敢懈怠，最好还好算没出什么岔子，安全上线。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;时间一转眼就来到五月份，如果没有记错的话郝磊同学应该是结束闭关重新回到杭州，回到杭州之后开始找工作之旅，不过我推荐给我们公司HR竟然一点反应都没有，实在是令人失望至极。郝童鞋在经过一个月找工作后由于个人要求高没有找到满意工作，恰我这里有空房间空余就让他搬过来住，然后经过三个星期的面试找到一个医疗行业的创业公司，顺利入职。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很快夏天就到了，夏天老婆说想学游泳，于是我们又去国信家园的游泳馆办了一张游泳卡，老婆在经过前几次的学习之后，已经可以戴着水袖独自游了，再我托着的情况下可以不用水袖游，不过可惜的是因为种种原因，游泳卡还有18次没有用完，老婆最终没有学会游泳。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;去年的夏天不太热，突然有一天我看到了御景蓝湾的广告，其实应该算是注意到，因为之前一直有看到但是没怎么在意，我又萌生了买房的念头，于是就一个人（其实是老婆不在家）跑到御景蓝湾的楼盘去看了，对房子的户型比较满意，所以当时就下定决心要买了。但是后来老婆去看了一下，对于房子其实也挺喜欢，但是因为周围车辆太多而且都是那种大货车，所以再看看，再看看的后果就是最后买了泊林春天。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;转眼就到了9月，这个时候郝童鞋因为经常要干到凌晨，所以辞去了工作，回到了重新找工作的路途中，在月底的时候已经确定要去北京，我正好有时间，在周末叫上郝磊去和董飞飞一起，这次由于董飞飞在地方，所以董飞飞做东，在他附近的外婆家吃了一顿，这一顿让我记住了那里的鸡，杭州其他地方的店都没有那家店好吃，以后有机会一定会再去吃。不过吃完这一顿，不知道和郝磊下一次一起吃饭得等到什么时候了，我和郝童鞋算是君子之交吧，一直喜欢和他交流，从他身上我能看到的不足，从他的谈话中总是让我收益。还有从那回来之后，因为我买房资金出了一点问题，我从飞飞那里借了4万块，飞飞毫不犹豫的借给我了，我非常感激。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;买了房之后感觉一颗心定下来了，现在只剩下一件事就是好好奋斗，将手中的工作做好。因为有一次需要拿一下现在我们库的注释，但是没有，然后用golang写了个程序，从之前我们的脚步中将注释脚步全部剥离出来，这样就是一个最新的全量脚步，跑以来一看又2M多，打这个注释脚步真的是要好长时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后时间就到了年底，说实话因为待遇问题我想走了，但是已经到了年底，还有就是办房贷如果换工作了还要重新办，实在麻烦，最重要的原因是现在我要去做2.0的业务，这一块其实我比较感兴趣的，所以我现在又开始观望了，明天合同到期再说吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;新的一年，希望2015我能做的更好，技术上业务上都要更上一层楼，还有就是要多多锻炼身体。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>发版141130</title>
      <link>http://www.wowzai.com/2014/version-release.html</link>
      <pubDate>2014-12-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上个周末，经历了一次痛苦的版本发布，为了版本的发布周末两天都在加班才勉强将版本发布出去，之所以说是勉强，是因为发布的版本中还有已知缺陷未修改。这样的版本发布之前也遇到过，不过由于人的健忘性，过了一段时间就抛在烟宵云外，就想没有发生过一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这次的发版之所以如此之赶，原因其实是我们开发这边在安排任务的时候没有考虑充分，将许多大的任务安排在了最后，导致最后一个星期全是大的任务，大任务做起来当然比较耗时间，再加上设计上的一些不足，还要不断修正，所以做起来就没有那么顺利，如果有问题也没有充分的时间重新设计、纠错。之所以大任务都集中在了最后一个星期，在一定程度上与我们的考核制度有关系，由于每个星期定任务的时候都需要定任务的条数，导致在设计人员在设计任务的时候为了赶着完成每个星期的设计任务数，所以会先设计一些简单的任务，将大的任务拖到最后。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;经过这次教训，我希望我们开发这边以后在设计、安排任务的时候一定要注意进度，尽量将任务安排均匀一些，同时要提高我们的设计质量，这样就不会有那么多的反反复复的修改。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>MySQL自增主键问题</title>
      <link>http://www.wowzai.com/2014/mysql_auto_increment_primary_key.html</link>
      <pubDate>2014-11-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;修改ID字段为自增主键：&#xA;alter table &lt;code&gt;test&lt;/code&gt; change &lt;code&gt;id&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; int (11) UNSIGNED NOT NULL AUTO_INCREMENT , add primary key (&lt;code&gt;id&lt;/code&gt; );&lt;/p&gt;&#xA;&#xA;&lt;p&gt;修改ID字段为自增非主键：&#xA;alter table &lt;code&gt;test&lt;/code&gt; change &lt;code&gt;id&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; int (11) UNSIGNED NOT NULL AUTO_INCREMENT , drop primary key;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;修改ID字段为普通字段：&#xA;alter table &lt;code&gt;test&lt;/code&gt; change &lt;code&gt;id&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; int (11) UNSIGNED NOT NULL ;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>阿里上市</title>
      <link>http://www.wowzai.com/2014/Alibaba-IPO.html</link>
      <pubDate>2014-09-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在家里看完《硅谷》（第一季），看到Richard经过一晚的努力他们的压缩软件的weissman评分提高到了5.2，那一刻不知道为什么，突然被感动的想哭，就好像自己的努力得到认可一样，恰好赶上阿里上市，祝贺阿里人，虽然我们互不认识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阿里上市，市值一举突破2000亿美元，阿里的很多员工都成了百万、千万富翁，我相信有很多实现了财务自由，祝贺这些获得获得自由的人，希望有那么一个时点，我也可以获得财务自由。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是最好的时代，也是最坏的时代，不过我相信这个世界正在一点点的变好，正确地努力付出的人终将得到回报。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>年轻真好</title>
      <link>http://www.wowzai.com/2014/young.html</link>
      <pubDate>2014-09-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;昨天爬完三清山，因为很长时间没有运动，虽然爬山的过程不是那么的吃力，但是以为第二天起来应该会酸痛，但是今天早上起来，发现没啥感觉，没觉得哪里酸哪里痛，突然发现年轻真好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们以五年的眼光来看的话,我们现在要做什么重要的事情，我们应该好好想一想，这样在五年之后才会得到想要的生活，最起码是接近。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本来想写很多，但是突然发现似乎又没有那么多要写的，呵呵，蛮好玩的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;趁着还年轻，多做一些事情，多做一些不会让自己后悔的事情，趁还能干得动的时候。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;观察自己是一件非常有趣的事情，有无数的乐趣可以体会到，真的很好玩。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>2014.09计划</title>
      <link>http://www.wowzai.com/2014/plan-of-2014-09.html</link>
      <pubDate>2014-09-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;废话不多说，先来总结上个月的计划完成情况：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.看完第四章：Oracle里的查询转换   完成50%，后期由于买房事宜耽误，但其实我知道这不是真正的理由&#xA;&#xA;2.游泳十次                       未完成，游泳三次，由于天气原因+发版计划，未能完成&#xA;&#xA;3.写三遍bolg                     完成，如果严格的话把买房的博文剔除的话，还是未完成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;首先，正视自己，诚实地面对自己，不再对自己定好高骛远的计划了，定了也没用，根本完不成，现在我需要更加务实地去制定计划，&#xA;我需要真正落地的计划，而不是完不成的to-do list。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;8月的主要时间是花在了买房的事宜上，包括看房、选择、权衡以及集资。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;9月的计划：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.看完第四章：Oracle里的查询转换&#xA;&#xA;2.跑步5公里&#xA;&#xA;3.写三篇blog&#xA;&#xA;4.跟着奶爸的学习方法，学完音标、English through Pictures 3本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;希望月底的时候能比8月有进步，对，只要有进步就OK。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>买房2</title>
      <link>http://www.wowzai.com/2014/buy-house-2.html</link>
      <pubDate>2014-08-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自从上次决定买房之后，这几个星期主要精力都用在了买房之上，我先是看了御景蓝湾的房子，看了他们的样板房，觉得挺好的，于是才决定买的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后来我老婆去看了一下，也觉得挺好的，只不过发现周围好多进城的卡车，尘土飞扬，觉得不安全，不卫生，我想也是，主要是不安全，以后小孩上学的路上碰到卡车多危险，卫不卫生倒不是很重要，起码对于我来说不是很重要。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是那时候已经决定买房了，所以周末（2014.8.16）就回家了，问家里人集点资，为马上的买房行为做好准备。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后来老婆在星光大道转悠，发现泊林春天的广告，两个人回来仔细的研究了一下，最后一致的认为这个地段比御景蓝湾的要好，唯一担心的就是价格，&#xA;因为那个时候还没开盘，价格还没公布，最后我还是让老婆先去看一下，后来由于各种原因，老婆也没有去看成，最后老婆建议我请个半天假我们两个人一起去看一下，我觉得也对，于是就上个星期二（2014.8.19）我请了下午的假，两个人一起去看了一下房子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那天天空不作美啊，下着雨，我们转了两次公交后终于到达目的地，在其中一次等公交的时候离楼盘不是很远，周围都是各种楼盘，然后我们几乎把周围的楼盘的电话打了个遍，尼玛，发现都买不起，晕。到了目的地之后，下车之后在你那荒郊野外的地方根本不知道怎么走，尼玛，老婆说不买了，太偏了啥的，我说既然都来了，先看了再说。于是找了又找，终于回头一看发现了楼盘的售楼处，两个人这才进去。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进去以后，一个售楼小姐开始招待我们，后来另一个售楼先生给我老婆打电话（来的路上给他打过电话没接），然后那个男的开始招待我们，两位交接的时候我看到售楼小姐难看的脸色，呵呵。介绍的过程就不表了，就是讲解了一下楼盘的位置，周围的设施等等，然后去看了样板房，对于样板房也表满意，除了厨房的设计，再后来就是聊了一会，基本就是我们问一些问题，他向我们介绍一下，然后我们就签了一个交5000抵20000的协议并把钱交了，之后就出来了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来就是比较回去了，找了下公交，发现有更加方便的公交，不过还是要转一次车，然后就是一起吃了个饭，你以为这个时候是要快快乐乐的回家了吗，当然不，一想到即将到来的债务，尼玛，我又乖乖的回到公司加班了，哈哈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;未完待续……&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>买房1</title>
      <link>http://www.wowzai.com/2014/buy-house-1.html</link>
      <pubDate>2014-08-10 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;决定买房了，嗯，就这样。&lt;/h3&gt;&#xA;</description>
    </item>
    <item>
      <title>2014.08计划</title>
      <link>http://www.wowzai.com/2014/plan-of-2014-08.html</link>
      <pubDate>2014-08-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从今年的五月份开始，每个月我都给自己订立计划，经过三个月的失败（2014.05、2014.06、2014.07），我彻底醒悟，发现我&#xA;之前订立的计划根本没有一个月是完全完成的，我分析了一下，主要有两个原因：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.加班太忙，几乎每天加班，导致没有自己的时间干自己的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.时间没有分配好，有时候闲了一下，还不知道干什么，这个时候最容易偷懒。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.效率太低，单位时间活干的较少，这其实涉及到自己基本功的问题，基本功不扎实导致学东西的时候效率较低，&#xA;这个还得慢慢来补。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;鉴于前面三个月的失败案例，决定从这个月起，将计划减少，不要设置很多个计划，到最后都没有完成。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;看完第四章：Oracle里的查询转换&#xA;&#xA;游泳十次&#xA;&#xA;写三遍bolg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>golang中获取中文字符串的子串字符位置及截取子串</title>
      <link>http://www.wowzai.com/2014/chinese-string-in-golang.html</link>
      <pubDate>2014-08-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;昨天准备用golang做一个简单的文本分析，需要简单的对字符串进行一些操作，在查看了strings和strconv库时，我没找到截取字符串的函数，同时strings.Index返回的是子串的字节位置，例如这个例子：strings.Index(&amp;ldquo;早上好，张先生！&amp;rdquo;,&amp;ldquo;好&amp;rdquo;) 的返回值是6，而不是2（从0开始算）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是我自己写了一个处理中文的返回字符串子串位置的函数，思想其实很简单，首先通过strings库中的Index函数获得子串的字节位置，再通过这个位置获得子串之前的字节数组pre，再将pre转换成[]rune，获得[]rune的长度，便是子串之前字符串的长度，也就是子串在字符串中的字符位置，具体代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func UnicodeIndex(str,substr string) int {&#xA;  // 子串在字符串的字节位置&#xA;  result := strings.Index(str,substr)  &#xA;  if result &amp;gt;= 0 {&#xA;    // 获得子串之前的字符串并转换成[]byte&#xA;    prefix := []byte(str)[0:result]  &#xA;    // 将子串之前的字符串转换成[]rune&#xA;    rs := []rune(string(prefix))  &#xA;    // 获得子串之前的字符串的长度，便是子串在字符串的字符位置&#xA;    result = len(rs)&#xA;  }&#xA;&#xA;  return result&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意，这里用的是string.Index函数，类似的，也可以写中文字符串的类似strings中的IndexAny,LastIndex等函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的思想，我也写了一个截取中文字符串的函数，如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func SubString(str string,begin,length int) (substr string) {&#xA;  // 将字符串的转换成[]rune&#xA;  rs := []rune(str)&#xA;  lth := len(rs)&#xA;&#xA;  // 简单的越界判断&#xA;  if begin &amp;lt; 0 {&#xA;    begin = 0&#xA;  }&#xA;  if begin &amp;gt;= lth {&#xA;    begin = lth&#xA;  }&#xA;  end := begin + length&#xA;  if end &amp;gt; lth {&#xA;    end = lth &#xA;  }&#xA;&#xA;  // 返回子串&#xA;  return string(rs[begin:end])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>投资自己</title>
      <link>http://www.wowzai.com/2014/invest-myself.html</link>
      <pubDate>2014-07-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##投资自己&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天老大找我谈了一下，大概说了下接下来的一些计划。接下来钢哥负责基金公司、基金子公司的需求，锋哥负责证券公司的需求，我负责内部需求，对外接口以及代码审核的工作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前由于人手的问题，我们的代码审核一直流于形式，是最容易丢的一块，接下来会当作一项任务来抓，我接下来将会用更多的精力放在代码上，这也是我希望的，我现在还不想太希望追着业务，赶着任务，我想把更多的精力放在代码上对于我无论是技术上还是业务上都是要好一些。接下来，我将会花上三个月左右的时间将我们的系统系统地梳理一遍，按照业务线一遍遍来，然后梳理成笔记，整理成文章，应该会放在这里，同时会将系统中涉及到的Oracle方面的一些知识，主要是SQL优化方面的知识也会整理一下放在这里，这样也算是对于我这两年工作的一个总结。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过呢，每个员工对于公司来说都是生产资料，公司希望每个生产资料都能发挥最大的作用，最好的情况是每个员工的方向和公司希望他走的方向是一致的，但是如果两者有冲突的时候，相信大部分情况下公司会选择公司利益最大化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，我想接下来，我将会将自己的精力更多地放在自己的事情上，主要是晚上的时间，golang、Android我来了！未来一定会更好的，加油！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>come on</title>
      <link>http://www.wowzai.com/2014/come-on.html</link>
      <pubDate>2014-07-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Come on&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一晃一个星期又过去了，周末在家啥也没干，尼玛，感觉这辈子是不是没得救了，卧槽。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过今天把房子租出去了，算是了了一件事，不用再为房子的事情烦心了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;之前安排好的计划看来又要拖延了，尼玛，接下来要更加地努力了，加油！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android Activity生命周期</title>
      <link>http://www.wowzai.com/2014/android-activity-lifecycle.html</link>
      <pubDate>2014-07-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Android Activity的生命周期&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要想谈谈Android Activity的生命周期，当然要从官方文档中的这个图说起：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;file:///D:/Android/adt-bundle-windows-x86_64-20140321/sdk/docs_backup0/images/activity_lifecycle.png&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其实从这个图已经可以很清楚的看到一个Activity的整个生命周期，不过我们还是要做个实验。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;    &#xA;    public static final String TAG = &amp;quot;MainActivity&amp;quot;;&#xA;    &#xA;    @Override&#xA;    protected void onCreate(Bundle savedInstanceState) {&#xA;        super.onCreate(savedInstanceState);&#xA;        setContentView(R.layout.activity_main);&#xA;        &#xA;        System.out.println(&amp;quot;MainActivity onCreate&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onCreate&amp;quot;);&#xA;        &#xA;&#xA;        if (savedInstanceState == null) {&#xA;            getSupportFragmentManager().beginTransaction()&#xA;                    .add(R.id.container, new PlaceholderFragment())&#xA;                    .commit();&#xA;        }&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onStart() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onStart();&#xA;        System.out.println(&amp;quot;MainActivity onStart&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onStart&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onResume() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onResume();&#xA;        System.out.println(&amp;quot;MainActivity onResume&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onResume&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onPause() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onPause();&#xA;        System.out.println(&amp;quot;MainActivity onPause&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onPause&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onStop() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onStop();&#xA;        System.out.println(&amp;quot;MainActivity onStop&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onStop&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onRestart() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onRestart();&#xA;        System.out.println(&amp;quot;MainActivity onRestart&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onRestart&amp;quot;);&#xA;    }&#xA;    &#xA;    @Override&#xA;    protected void onDestroy() {&#xA;        // TODO Auto-generated method stub&#xA;        super.onDestroy();&#xA;        System.out.println(&amp;quot;MainActivity onDestory&amp;quot;);&#xA;        Log.e(TAG, &amp;quot;MainActivity onDestory&amp;quot;);&#xA;    }  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我这里不知道怎么回事，LogCat无法打印日期，这个问题回头再查，我只好用Debug模式跟进去看看这几个函数执行的先后顺序。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先启动时，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onCreate&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此，这里前台已经可以展示内容，此时按下Home键，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;重新点开应用程序，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此前台可以看到展示内容，此时按下Back键，会调用到&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onDestory&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从这个过程可以看到在OnResume和OnPause之间Activity是可见的，官方文档指出如果我们有需要永久保存的内容，我们最好是在OnPause()中实现，同时Back键是会Destory对应的Activity的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当有两个Activity时，其中一个Activity是由另一个Activity驱动打开的，例如一个是MainActivity，界面中有一个按钮,点击这个按钮之后会启动另一个Activity，例如叫OtherActivity，此时启动主程序首先进入的是MainActivity，调用顺序如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时可以看到MainActivity中的内容，可以看到MainActivity中有一个Click按钮，点击这个按钮会启动另一个Activity&amp;ndash;OtherActivity。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;点击Click按钮，MainActivity会先暂停，调用：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后启动OtherActivity：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onCreate&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候OtherActivity已经展现出来，接下来会将MainActivity停止掉，调用：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候再点击Back键，OtherActivity会先暂停，然后MainActivity会重启：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;MainActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时返回到MainActivity的界面，同时OtherActivity会停止并销毁：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onDestory&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果在OtherActivity界面展现的时候，不点击Back而是点击Home键，&#xA;调用顺序将是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onPause&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStop&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从桌面点击程序图标启动程序，此时会OtherActivity会重启，回到按Home键之前的状态：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onRestart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onStart&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;System.out.println(&amp;ldquo;OtherActivity onResume&amp;rdquo;);&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>net.http如何提供http服务的大致实现</title>
      <link>http://www.wowzai.com/2014/http-in-golang.html</link>
      <pubDate>2014-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天粗略的看了一下net.http的Server端的实现，总体上算是了解其大致的实现。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;golang建立一个web server&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;用golang建立一个web server是一件非常容易的一件事，在&lt;a href=&#34;http://golang.org/doc/effective_go.html#web_server&#34;&gt;Effective_go&lt;/a&gt;中就有个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;flag&amp;quot;&#xA;    &amp;quot;html/template&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;var addr = flag.String(&amp;quot;addr&amp;quot;, &amp;quot;:1718&amp;quot;, &amp;quot;http service address&amp;quot;) // Q=17, R=18&#xA;&#xA;var templ = template.Must(template.New(&amp;quot;qr&amp;quot;).Parse(templateStr))&#xA;&#xA;func main() {&#xA;    flag.Parse()&#xA;    http.Handle(&amp;quot;/&amp;quot;, http.HandlerFunc(QR))&#xA;    err := http.ListenAndServe(*addr, nil)&#xA;    if err != nil {&#xA;    log.Fatal(&amp;quot;ListenAndServe:&amp;quot;, err)&#xA;    }&#xA;}&#xA;&#xA;func QR(w http.ResponseWriter, req *http.Request) {&#xA;    templ.Execute(w, req.FormValue(&amp;quot;s&amp;quot;))&#xA;}&#xA;&#xA;const templateStr = `&#xA;&amp;lt;html&amp;gt;&#xA;&amp;lt;head&amp;gt;&#xA;&amp;lt;title&amp;gt;QR Link Generator&amp;lt;/title&amp;gt;&#xA;&amp;lt;/head&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&#xA;&amp;lt;img src=&amp;quot;http://chart.apis.google.com/chart?chs=300x300&amp;amp;cht=qr&amp;amp;choe=UTF-8&amp;amp;chl=map[site:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] data:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] layouts:map[default:map[_content:0xc08405fc60] page:map[layout:default _content:0xc08405fcf0] post:map[layout:default _content:0xc08405fdb0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc08405f870 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041660 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041990 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:wowzai的账簿 _content:0xc084041bd0 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041db0 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041fc0 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\Array和Slice.md:map[date:2014-07-09 layout:post categories:[Blog] tags:[golang] id:posts\Array和Slice.md url:/2014/array-and-slice-in-golang.html title:Array和Slice permalink:/2014/array-and-slice-in-golang.html _content:0xc084095f90 _date:2014-07-09 00:00:00 +0000 UTC] posts\Invest myself.md:map[layout:post title:投资自己 permalink:/2014/invest-myself.html categories:[Blog] tags:[life] id:posts\Invest myself.md url:/2014/invest-myself.html date:2014-07-21 _content:0xc08405fed0 _date:2014-07-21 00:00:00 +0000 UTC] posts\golang中获取中文字符串的子串字符位置及截取子串.md:map[permalink:/2014/chinese-string-in-golang.html tags:[golang] _content:0xc084095c60 date:2014-08-04 layout:post title:golang中获取中文字符串的子串字符位置及截取子串 categories:[Blog] id:posts\golang中获取中文字符串的子串字符位置及截取子串.md _date:2014-08-04 00:00:00 +0000 UTC url:/2014/chinese-string-in-golang.html] posts\把时间当作朋友读书笔记1.md:map[date:2015-04-15 permalink:/2015/reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html categories:[Blog] _content:0xc084093f90 id:posts\把时间当作朋友读书笔记1.md _date:2015-04-15 00:00:00 +0000 UTC layout:post title:《把时间当作朋友》读书笔记（上） tags:[plan] url:/2015/reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html] posts\MySQL自增主键问题.md:map[date:2014-11-12 layout:post categories:[Blog] tags:[plan] _content:0xc084095990 id:posts\MySQL自增主键问题.md url:/2014/mysql_auto_increment_primary_key.html title:MySQL自增主键问题 permalink:/2014/mysql_auto_increment_primary_key.html _date:2014-11-12 00:00:00 +0000 UTC] posts\Oracle中的执行计划.md:map[date:2014-06-27 layout:post title:Oracle中的执行计划 permalink:/2014/oracle-explain-plan-1.html _content:0xc084095d20 id:posts\Oracle中的执行计划.md _date:2014-06-27 00:00:00 +0000 UTC url:/2014/oracle-explain-plan-1.html categories:[Blog] tags:[Oracle Explain plan]] posts\first-blog.md:map[layout:post title:我的第一篇Blog permalink:/2014/new-born.html categories:[Blog] tags:[new born] _date:2014-05-15 00:00:00 +0000 UTC date:2014-05-15 _content:0xc084095540 id:posts\first-blog.md url:/2014/new-born.html] posts\jQuery学习笔记1.md:map[title:jQuery学习笔记1 permalink:/2015/jQuery-notes-1.html categories:[Blog] _content:0xc08405ff60 id:posts\jQuery学习笔记1.md url:/2015/jQuery-notes-1.html date:2015-05-24 layout:post tags:[JavaScript jQuery notes] _date:2015-05-24 00:00:00 +0000 UTC] posts\发版141130.md:map[date:2014-12-01 title:发版141130 tags:[工作] id:posts\发版141130.md _date:2014-12-01 00:00:00 +0000 UTC url:/2014/version-release.html layout:post permalink:/2014/version-release.html categories:[Blog] _content:0xc0840939f0] posts\阿里上市.md:map[date:2014-09-20 layout:post permalink:/2014/Alibaba-IPO.html tags:[plan] url:/2014/Alibaba-IPO.html title:阿里上市 categories:[Blog] _content:0xc084093150 id:posts\阿里上市.md _date:2014-09-20 00:00:00 +0000 UTC] posts\本命年总结.md:map[layout:post categories:[Blog] _content:0xc0840954e0 id:posts\本命年总结.md _date:2015-02-07 00:00:00 +0000 UTC url:/2015/summary-2014.html date:2015-02-07 title:年终总结 permalink:/2015/summary-2014.html tags:[golang]] posts\2014.09.Plan.md:map[date:2014-09-03 permalink:/2014/plan-of-2014-09.html tags:[plan] _content:0xc084095b70 _date:2014-09-03 00:00:00 +0000 UTC url:/2014/plan-of-2014-09.html layout:post title:2014.09计划 categories:[Blog] id:posts\2014.09.Plan.md] posts\JavaScript学习笔记.md:map[title:jQuery学习笔记1 tags:[JavaScript jQuery notes] _content:0xc084095510 id:posts\JavaScript学习笔记.md date:2015-05-24 layout:post permalink:/2015/JavaScript-notes.html categories:[Blog] _date:2015-05-24 00:00:00 +0000 UTC url:/2015/JavaScript-notes.html] posts\关于最近.md:map[layout:post permalink:/2014/2014-my-life-06.html _content:0xc0840936f0 url:/2014/2014-my-life-06.html date:2014-06-28 title:关于最近 categories:[Blog] tags:[my life work] id:posts\关于最近.md _date:2014-06-28 00:00:00 +0000 UTC] posts\Come On.md:map[layout:post permalink:/2014/come-on.html tags:[pieces] _date:2014-07-20 00:00:00 +0000 UTC url:/2014/come-on.html date:2014-07-20 title:come on categories:[Blog] _content:0xc08405f6c0 id:posts\Come On.md] posts\Windows下查看端口和进程绑定.md:map[date:2014-06-26 title:Windows下查看端口和进程绑定 _date:2014-06-26 00:00:00 +0000 UTC layout:post permalink:/2014/Windows下查看端口和进程绑定.html categories:[Blog] tags:[windows] _content:0xc08405f300 id:posts\Windows下查看端口和进程绑定.md url:/2014/Windows下查看端口和进程绑定.html] posts\买房2.md:map[title:买房2 categories:[Blog] tags:[plan] _content:0xc0840933f0 id:posts\买房2.md url:/2014/buy-house-2.html date:2014-08-26 layout:post permalink:/2014/buy-house-2.html _date:2014-08-26 00:00:00 +0000 UTC] posts\把时间当作朋友读书笔记2.md:map[date:2015-04-30 permalink:/2015/second-reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html tags:[plan] id:posts\把时间当作朋友读书笔记2.md _date:2015-04-30 00:00:00 +0000 UTC url:/2015/second-reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html layout:post title:《把时间当作朋友》读书笔记（下） categories:[Blog] _content:0xc084093210] posts\自我git教程.md:map[categories:[Blog] _content:0xc084095ae0 date:2014-06-30 layout:post title:git自我教程 permalink:/2014/my-git-manual.html tags:[git 教程] id:posts\自我git教程.md _date:2014-06-30 00:00:00 +0000 UTC url:/2014/my-git-manual.html] posts\Method Value和Method Expression.md:map[date:2014-07-08 layout:post title:Method Value和Method Expression permalink:/2014/method-value-vs-method-expression-in-golang.html tags:[golang] id:posts\Method Value和Method Expression.md _date:2014-07-08 00:00:00 +0000 UTC url:/2014/method-value-vs-method-expression-in-golang.html categories:[Blog] _content:0xc084095750] posts\golang中defer执行位置.md:map[date:2014-07-07 layout:post categories:[Blog] tags:[golang] id:posts\golang中defer执行位置.md _date:2014-07-07 00:00:00 +0000 UTC title:golang中defer的执行位置 permalink:/2014/defer-in-golang.html _content:0xc0840959f0 url:/2014/defer-in-golang.html] posts\为什么那么穷还要去旅行.md:map[layout:post categories:[Blog] _content:0xc084041c00 _date:2014-06-30 00:00:00 +0000 UTC date:2014-06-30 title:那么穷为什么还要去旅行 permalink:/2014/travel-really.html tags:[思考 旅行] id:posts\为什么那么穷还要去旅行.md url:/2014/travel-really.html] posts\年轻真好.md:map[layout:post permalink:/2014/young.html categories:[Blog] tags:[plan] id:posts\年轻真好.md _date:2014-09-08 00:00:00 +0000 UTC url:/2014/young.html date:2014-09-08 title:年轻真好 _content:0xc084093c30] posts\2014.08.Plan.md:map[permalink:/2014/plan-of-2014-08.html categories:[Blog] tags:[plan] _date:2014-08-05 00:00:00 +0000 UTC date:2014-08-05 layout:post title:2014.08计划 _content:0xc084095870 id:posts\2014.08.Plan.md url:/2014/plan-of-2014-08.html] posts\Android Activity生命周期.md:map[date:2014-07-16 layout:post title:Android Activity生命周期 permalink:/2014/android-activity-lifecycle.html categories:[Blog] tags:[Android Activity] id:posts\Android Activity生命周期.md url:/2014/android-activity-lifecycle.html _content:0xc084095d80 _date:2014-07-16 00:00:00 +0000 UTC] posts\golang的net.http的简单分析1.md:map[date:2014-07-10 title:net.http如何提供http服务的大致实现 categories:[Blog] url:/2014/http-in-golang.html layout:post permalink:/2014/http-in-golang.html tags:[golang] _content:0xc08405f4e0 id:posts\golang的net.http的简单分析1.md _date:2014-07-10 00:00:00 +0000 UTC] posts\买房.md:map[permalink:/2014/buy-house-1.html categories:[Blog] _date:2014-08-10 00:00:00 +0000 UTC url:/2014/buy-house-1.html date:2014-08-10 layout:post title:买房1 tags:[plan] _content:0xc084093090 id:posts\买房.md] posts\我的生活由你负责.md:map[date:2015-03-15 title:我的生活由你负责 permalink:/2015/my-life-is-your-responsibility.html categories:[Blog] _content:0xc084093e40 id:posts\我的生活由你负责.md _date:2015-03-15 00:00:00 +0000 UTC layout:post tags:[life] url:/2015/my-life-is-your-responsibility.html]] tags:map[JavaScript:0xc0840e2340 windows:0xc0840e2540 旅行:0xc0840e27c0 Activity:0xc0840e2840 life:0xc0840e2900 Oracle:0xc0840e2980 work:0xc0840e2480 git:0xc0840e2600 教程:0xc0840e2640 golang:0xc0840e26c0 Android:0xc0840e2800 Explain plan:0xc0840e29c0 plan:0xc0840e22c0 notes:0xc0840e23c0 pieces:0xc0840e2500 new born:0xc0840e2a00 jQuery:0xc0840e2380 my life:0xc0840e2440 思考:0xc0840e2780 工作:0xc0840e2a40] categories:map[Blog:0xc0840e2300] chronological:[posts\jQuery学习笔记1.md posts\JavaScript学习笔记.md posts\把时间当作朋友读书笔记2.md posts\把时间当作朋友读书笔记1.md posts\我的生活由你负责.md posts\本命年总结.md posts\发版141130.md posts\MySQL自增主键问题.md posts\阿里上市.md posts\年轻真好.md posts\2014.09.Plan.md posts\买房2.md posts\买房.md posts\2014.08.Plan.md posts\golang中获取中文字符串的子串字符位置及截取子串.md posts\Invest myself.md posts\Come On.md posts\Android Activity生命周期.md posts\golang的net.http的简单分析1.md posts\Array和Slice.md posts\Method Value和Method Expression.md posts\golang中defer执行位置.md posts\自我git教程.md posts\为什么那么穷还要去旅行.md posts\关于最近.md posts\Oracle中的执行计划.md posts\Windows下查看端口和进程绑定.md posts\first-blog.md] collated:[0xc0840933c0 0xc0840932d0]]]]&amp;quot; /&amp;gt;&#xA;&amp;lt;br&amp;gt;&#xA;map[site:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] data:map[title:wowzai&amp;amp;#39;s blog tagline:In God we trust. Everyone else, bring data author:map[name:wowzai email:code.fun.dev@gmail.com github:codebook twitter:username feedburner:feedname] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://www.wowzai.com posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:] imgs:map[imgtag:&amp;amp;lt;img src=&amp;amp;#34;%s&amp;amp;#34; alt=&amp;amp;#34;&amp;amp;#34; width=&amp;amp;#34;600&amp;amp;#34;&amp;amp;gt; urlperfix:{{urls.media}}/ localdir:media/]]] layouts:map[default:map[_content:0xc08405fc60] page:map[layout:default _content:0xc08405fcf0] post:map[layout:default _content:0xc08405fdb0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc08405f870 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041660 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041990 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:wowzai的账簿 _content:0xc084041bd0 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041db0 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc084041fc0 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\Come On.md:map[date:2014-07-20 title:come on categories:[Blog] _content:0xc08405f6c0 id:posts\Come On.md layout:post permalink:/2014/come-on.html tags:[pieces] _date:2014-07-20 00:00:00 +0000 UTC url:/2014/come-on.html] posts\Windows下查看端口和进程绑定.md:map[layout:post permalink:/2014/Windows下查看端口和进程绑定.html categories:[Blog] tags:[windows] _content:0xc08405f300 id:posts\Windows下查看端口和进程绑定.md url:/2014/Windows下查看端口和进程绑定.html date:2014-06-26 title:Windows下查看端口和进程绑定 _date:2014-06-26 00:00:00 +0000 UTC] posts\买房2.md:map[title:买房2 categories:[Blog] tags:[plan] _content:0xc0840933f0 id:posts\买房2.md url:/2014/buy-house-2.html date:2014-08-26 layout:post permalink:/2014/buy-house-2.html _date:2014-08-26 00:00:00 +0000 UTC] posts\把时间当作朋友读书笔记2.md:map[layout:post title:《把时间当作朋友》读书笔记（下） categories:[Blog] _content:0xc084093210 date:2015-04-30 permalink:/2015/second-reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html tags:[plan] id:posts\把时间当作朋友读书笔记2.md _date:2015-04-30 00:00:00 +0000 UTC url:/2015/second-reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html] posts\自我git教程.md:map[categories:[Blog] _content:0xc084095ae0 date:2014-06-30 layout:post title:git自我教程 permalink:/2014/my-git-manual.html tags:[git 教程] id:posts\自我git教程.md _date:2014-06-30 00:00:00 +0000 UTC url:/2014/my-git-manual.html] posts\Method Value和Method Expression.md:map[categories:[Blog] _content:0xc084095750 date:2014-07-08 layout:post title:Method Value和Method Expression permalink:/2014/method-value-vs-method-expression-in-golang.html tags:[golang] id:posts\Method Value和Method Expression.md _date:2014-07-08 00:00:00 +0000 UTC url:/2014/method-value-vs-method-expression-in-golang.html] posts\golang中defer执行位置.md:map[title:golang中defer的执行位置 permalink:/2014/defer-in-golang.html _content:0xc0840959f0 url:/2014/defer-in-golang.html date:2014-07-07 layout:post categories:[Blog] tags:[golang] id:posts\golang中defer执行位置.md _date:2014-07-07 00:00:00 +0000 UTC] posts\为什么那么穷还要去旅行.md:map[date:2014-06-30 title:那么穷为什么还要去旅行 permalink:/2014/travel-really.html tags:[思考 旅行] id:posts\为什么那么穷还要去旅行.md url:/2014/travel-really.html layout:post categories:[Blog] _content:0xc084041c00 _date:2014-06-30 00:00:00 +0000 UTC] posts\年轻真好.md:map[layout:post permalink:/2014/young.html categories:[Blog] tags:[plan] id:posts\年轻真好.md _date:2014-09-08 00:00:00 +0000 UTC url:/2014/young.html date:2014-09-08 title:年轻真好 _content:0xc084093c30] posts\2014.08.Plan.md:map[permalink:/2014/plan-of-2014-08.html categories:[Blog] tags:[plan] _date:2014-08-05 00:00:00 +0000 UTC date:2014-08-05 layout:post title:2014.08计划 _content:0xc084095870 id:posts\2014.08.Plan.md url:/2014/plan-of-2014-08.html] posts\Android Activity生命周期.md:map[date:2014-07-16 layout:post title:Android Activity生命周期 permalink:/2014/android-activity-lifecycle.html categories:[Blog] tags:[Android Activity] id:posts\Android Activity生命周期.md url:/2014/android-activity-lifecycle.html _content:0xc084095d80 _date:2014-07-16 00:00:00 +0000 UTC] posts\golang的net.http的简单分析1.md:map[date:2014-07-10 title:net.http如何提供http服务的大致实现 categories:[Blog] url:/2014/http-in-golang.html layout:post permalink:/2014/http-in-golang.html tags:[golang] _content:0xc08405f4e0 id:posts\golang的net.http的简单分析1.md _date:2014-07-10 00:00:00 +0000 UTC] posts\买房.md:map[permalink:/2014/buy-house-1.html categories:[Blog] _date:2014-08-10 00:00:00 +0000 UTC url:/2014/buy-house-1.html date:2014-08-10 layout:post title:买房1 tags:[plan] _content:0xc084093090 id:posts\买房.md] posts\我的生活由你负责.md:map[date:2015-03-15 title:我的生活由你负责 permalink:/2015/my-life-is-your-responsibility.html categories:[Blog] _content:0xc084093e40 id:posts\我的生活由你负责.md _date:2015-03-15 00:00:00 +0000 UTC layout:post tags:[life] url:/2015/my-life-is-your-responsibility.html] posts\Array和Slice.md:map[date:2014-07-09 layout:post categories:[Blog] tags:[golang] id:posts\Array和Slice.md url:/2014/array-and-slice-in-golang.html title:Array和Slice permalink:/2014/array-and-slice-in-golang.html _content:0xc084095f90 _date:2014-07-09 00:00:00 +0000 UTC] posts\Invest myself.md:map[layout:post title:投资自己 permalink:/2014/invest-myself.html categories:[Blog] tags:[life] id:posts\Invest myself.md url:/2014/invest-myself.html date:2014-07-21 _content:0xc08405fed0 _date:2014-07-21 00:00:00 +0000 UTC] posts\golang中获取中文字符串的子串字符位置及截取子串.md:map[date:2014-08-04 layout:post title:golang中获取中文字符串的子串字符位置及截取子串 categories:[Blog] id:posts\golang中获取中文字符串的子串字符位置及截取子串.md _date:2014-08-04 00:00:00 +0000 UTC url:/2014/chinese-string-in-golang.html permalink:/2014/chinese-string-in-golang.html tags:[golang] _content:0xc084095c60] posts\把时间当作朋友读书笔记1.md:map[layout:post title:《把时间当作朋友》读书笔记（上） tags:[plan] url:/2015/reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html date:2015-04-15 permalink:/2015/reading-notes-of-ba-shi-jian-dang-zuo-peng-you.html categories:[Blog] _content:0xc084093f90 id:posts\把时间当作朋友读书笔记1.md _date:2015-04-15 00:00:00 +0000 UTC] posts\MySQL自增主键问题.md:map[title:MySQL自增主键问题 permalink:/2014/mysql_auto_increment_primary_key.html _date:2014-11-12 00:00:00 +0000 UTC date:2014-11-12 layout:post categories:[Blog] tags:[plan] _content:0xc084095990 id:posts\MySQL自增主键问题.md url:/2014/mysql_auto_increment_primary_key.html] posts\Oracle中的执行计划.md:map[categories:[Blog] tags:[Oracle Explain plan] date:2014-06-27 layout:post title:Oracle中的执行计划 permalink:/2014/oracle-explain-plan-1.html _content:0xc084095d20 id:posts\Oracle中的执行计划.md _date:2014-06-27 00:00:00 +0000 UTC url:/2014/oracle-explain-plan-1.html] posts\first-blog.md:map[date:2014-05-15 _content:0xc084095540 id:posts\first-blog.md url:/2014/new-born.html layout:post title:我的第一篇Blog permalink:/2014/new-born.html categories:[Blog] tags:[new born] _date:2014-05-15 00:00:00 +0000 UTC] posts\jQuery学习笔记1.md:map[title:jQuery学习笔记1 permalink:/2015/jQuery-notes-1.html categories:[Blog] _content:0xc08405ff60 id:posts\jQuery学习笔记1.md url:/2015/jQuery-notes-1.html date:2015-05-24 layout:post tags:[JavaScript jQuery notes] _date:2015-05-24 00:00:00 +0000 UTC] posts\发版141130.md:map[date:2014-12-01 title:发版141130 tags:[工作] id:posts\发版141130.md _date:2014-12-01 00:00:00 +0000 UTC url:/2014/version-release.html layout:post permalink:/2014/version-release.html categories:[Blog] _content:0xc0840939f0] posts\阿里上市.md:map[title:阿里上市 categories:[Blog] _content:0xc084093150 id:posts\阿里上市.md _date:2014-09-20 00:00:00 +0000 UTC date:2014-09-20 layout:post permalink:/2014/Alibaba-IPO.html tags:[plan] url:/2014/Alibaba-IPO.html] posts\本命年总结.md:map[date:2015-02-07 title:年终总结 permalink:/2015/summary-2014.html tags:[golang] layout:post categories:[Blog] _content:0xc0840954e0 id:posts\本命年总结.md _date:2015-02-07 00:00:00 +0000 UTC url:/2015/summary-2014.html] posts\2014.09.Plan.md:map[layout:post title:2014.09计划 categories:[Blog] id:posts\2014.09.Plan.md date:2014-09-03 permalink:/2014/plan-of-2014-09.html tags:[plan] _content:0xc084095b70 _date:2014-09-03 00:00:00 +0000 UTC url:/2014/plan-of-2014-09.html] posts\JavaScript学习笔记.md:map[date:2015-05-24 layout:post permalink:/2015/JavaScript-notes.html categories:[Blog] _date:2015-05-24 00:00:00 +0000 UTC url:/2015/JavaScript-notes.html title:jQuery学习笔记1 tags:[JavaScript jQuery notes] _content:0xc084095510 id:posts\JavaScript学习笔记.md] posts\关于最近.md:map[date:2014-06-28 title:关于最近 categories:[Blog] tags:[my life work] id:posts\关于最近.md _date:2014-06-28 00:00:00 +0000 UTC layout:post permalink:/2014/2014-my-life-06.html _content:0xc0840936f0 url:/2014/2014-my-life-06.html]] tags:map[JavaScript:0xc0840e2340 windows:0xc0840e2540 旅行:0xc0840e27c0 Activity:0xc0840e2840 life:0xc0840e2900 Oracle:0xc0840e2980 work:0xc0840e2480 git:0xc0840e2600 教程:0xc0840e2640 golang:0xc0840e26c0 Android:0xc0840e2800 Explain plan:0xc0840e29c0 plan:0xc0840e22c0 notes:0xc0840e23c0 pieces:0xc0840e2500 new born:0xc0840e2a00 jQuery:0xc0840e2380 my life:0xc0840e2440 思考:0xc0840e2780 工作:0xc0840e2a40] categories:map[Blog:0xc0840e2300] chronological:[posts\jQuery学习笔记1.md posts\JavaScript学习笔记.md posts\把时间当作朋友读书笔记2.md posts\把时间当作朋友读书笔记1.md posts\我的生活由你负责.md posts\本命年总结.md posts\发版141130.md posts\MySQL自增主键问题.md posts\阿里上市.md posts\年轻真好.md posts\2014.09.Plan.md posts\买房2.md posts\买房.md posts\2014.08.Plan.md posts\golang中获取中文字符串的子串字符位置及截取子串.md posts\Invest myself.md posts\Come On.md posts\Android Activity生命周期.md posts\golang的net.http的简单分析1.md posts\Array和Slice.md posts\Method Value和Method Expression.md posts\golang中defer执行位置.md posts\自我git教程.md posts\为什么那么穷还要去旅行.md posts\关于最近.md posts\Oracle中的执行计划.md posts\Windows下查看端口和进程绑定.md posts\first-blog.md] collated:[0xc0840933c0 0xc0840932d0]]]]&#xA;&amp;lt;br&amp;gt;&#xA;&amp;lt;br&amp;gt;&#xA;&#xA;&amp;lt;form action=&amp;quot;/&amp;quot; name=f method=&amp;quot;GET&amp;quot;&amp;gt;&amp;lt;input maxLength=1024 size=70&#xA;name=s value=&amp;quot;&amp;quot; title=&amp;quot;Text to QR Encode&amp;quot;&amp;gt;&amp;lt;input type=submit&#xA;value=&amp;quot;Show QR&amp;quot; name=qr&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt;&#xA;`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;因为net.http提供了web server的功能，这样可以很简单的建立一个页面供用户来访问，上面的例子中templateStr就是页面的html代码，可以用html/template的API来实现动态效果，具体可以查看&lt;a href=&#34;http://golang.org/pkg/html/template/&#34;&gt;template&lt;/a&gt;的API，然后有个HandlerFunc类型的函数，来处理response和request，这样就可以提供web服务了，真的很简单！&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Web Server的内部实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;仅仅对于使用，通过上面的例子再加上API的查询，相信就可以编写应用了，但是对于我，我还想了解一下其内部的具体实现，一来熟悉golang，从代码中学习，二来通过实践增加对于HTTP协议的了解，三来增强自己造轮子的能力，哈哈，真正的是一矢三鸟啊，想想就兴奋。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，通过上面的例子，可以知道这里主要是使用了两个函数完成，第一个http.Handle,第二个是http.ListenAndServe。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中，http.Handle接受两个参数，第一个是地址（可以看成于根的相对地址），用来路由页面的，第二个是一个接受ResponseWriter和*Request的函数。例子中函数QR就是一个，QR拿到Response和Request后可以进行一些处理，然后将结果返回给客户端。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;http.ListenAndServe是将会监听http服务并提供服务，那么他是如何工作的呢？首先创建一个Server，Server顾名思义就是服务端服务的提供者啦，它的定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A Server defines parameters for running an HTTP server.&#xA;type Server struct {&#xA;    Addr   string// TCP address to listen on, &amp;quot;:http&amp;quot; if empty&#xA;    Handler Handler   // handler to invoke, http.DefaultServeMux if nil&#xA;    ReadTimeouttime.Duration // maximum duration before timing out read of the request&#xA;    WriteTimeout   time.Duration // maximum duration before timing out write of the response&#xA;    MaxHeaderBytes int   // maximum size of request headers, DefaultMaxHeaderBytes if 0&#xA;    TLSConfig  *tls.Config   // optional TLS config, used by ListenAndServeTLS&#xA;&#xA;    // TLSNextProto optionally specifies a function to take over&#xA;    // ownership of the provided TLS connection when an NPN&#xA;    // protocol upgrade has occurred.  The map key is the protocol&#xA;    // name negotiated. The Handler argument should be used to&#xA;    // handle HTTP requests and will initialize the Request&#39;s TLS&#xA;    // and RemoteAddr if not already set.  The connection is&#xA;    // automatically closed when the function returns.&#xA;    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接受传进去的Addr作为建立TCP监听的地址，Handler作为Server的Hander。&#xA;通过net.Listen方法获得一个TCP的Listener l,在调用server的Serve方法，将l传进去，server在提供Serve的时候首先会根据传进来的listener获得一个conn，记住这个conn可是web server的基础哦，客户端和服务端的一切通信都是建立在它的基础之上，有个这个conn之后，才有可能提供web服务。server在拿到这个conn之后，会进行一些错误处理，然后对这个net.conn进行一层封装获得一个http connection，conn定义如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// A conn represents the server side of an HTTP connection.&#xA;    type conn struct {&#xA;        remoteAddr string   // network address of remote side&#xA;        server *Server      // the Server on which the connection arrived&#xA;        rwcnet.Conn         // i/o connection&#xA;        sr liveSwitchReader // where the LimitReader reads from; usually the rwc&#xA;        lr *io.LimitedReader// io.LimitReader(sr)&#xA;        buf*bufio.ReadWriter// buffered(lr,rwc), reading from bufio-&amp;gt;limitReader-&amp;gt;sr-&amp;gt;rwc&#xA;        bufswr *switchReader// the *switchReader io.Reader source of buf&#xA;        bufsww *switchWriter// the *switchWriter io.Writer dest of buf&#xA;        tlsState   *tls.ConnectionState // or nil when not using TLS&#xA;&#xA;        mu   sync.Mutex     // guards the following&#xA;        clientGone   bool   // if client has disconnected mid-request&#xA;        closeNotifyc chan bool  // made lazily&#xA;        hijackedvbool       // connection has been hijacked by handler&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;newConn会将net.Conn进行封装，在net.Conn执行封装一些BufferReader,BufferWriter，BufferReadWriter，switchReader等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有了这个conn之后，server就会调用它的serve方法提供服务了，serve方法中，会调用readRquest()获得一个response，这个response并不是http.Response，而是server端的response，与http.Response封装是不同嘀，它实现了ResponseWriter接口，response中有个成员是一个http.Request,有了ResponseWriter和Request之后，就可以调用用户自己实现的ServeHTTP处理逻辑处理数据并将结果返回给数据。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Array和Slice</title>
      <link>http://www.wowzai.com/2014/array-and-slice-in-golang.html</link>
      <pubDate>2014-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;Array&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Array可以看作一个有长度的变量，每个单元都可以存放一个元素，例如：&lt;br /&gt;&#xA;    var buffer [100]int&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在内存中buffer类似如下：&lt;br /&gt;&#xA;   &lt;code&gt;buffer: int int int ... 100 times ... int int int&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Array中的长度也是类型的一部分，例如[200]int和[100]int是不同类型的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;testArray(arr [100]int) {&#xA;  // ...&#xA;}&#xA;&#xA;var a1 [100]int&#xA;var a2 [200]int&#xA;&#xA;testArray(a1)  // OK&#xA;testArray(a2)  // Wrong&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Array可以用来表示矩阵，但是通常是作为slice的存储基础&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Slice Header&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Slice可以看作是Array的部分片段，而不是Array（A Slice is not an an array,a slice is piece of an array）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := array[10:20]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice也可以对slice进行“切片”：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s2 := slice[5:10]  //新定义一个变量s2，是对slice片段的描述&#xA;slice := slice[5:10]  //对自己切片并将变量付给自身&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以将Slice看成一个包含长度和起始地址的数据结构：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type sliceHeader struct {&#xA;  Length    int&#xA;  ZeroElement *int  //不一定是*int，元素是什么类型就是什么类型的指针&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;例如上面的slice变量可以看成如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := sliceHeader {&#xA;  Length: 10,&#xA;  ZeroElement: &amp;amp;array[10],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Slice作为函数参数传递&#xA;slice是一个包含长度和一个指针的结构体的值，而不是一个指向一个结构体的指针，函数参数中的slice在传进去的时候是一个struct值的复制值，修改slice中的元素值就是修改其所持有Array的元素值，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func AddSlice(slice []int) {  &#xA;  for i := range slice {  &#xA;    slice[i]++  &#xA;  }  &#xA;} &#xA;func main() {  &#xA;  slice := []int{1,2,3,4,5,6,7,8,9,10}  &#xA;  fmt.Println(&amp;quot;before:&amp;quot;,slice)  &#xA;  AddSlice(slice)  &#xA;  fmt.Println(&amp;quot;after:&amp;quot;,slice) &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pirint:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: [1,2,3,4,5,6,7,8,9,10]&#xA;after: [2,3,4,5,6,7,8,9,10,11]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数传递进去时候slice只是一个复制值，可以通过如下例子看出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func SubSlice(slice []int) []int {&#xA;  slice := slice[0:len(slice)-1]&#xA;  return slice&#xA;}&#xA;&#xA;func main() {&#xA;  slice := []int{1,2,3,4,5,6,7,8,9,10}  &#xA;  fmt.Println(&amp;quot;before: len(slice) =&amp;quot;,slice)  &#xA;  newSlice := SubSlice(slice)  &#xA;  fmt.Println(&amp;quot;after: len(slice) =&amp;quot;,slice)&#xA;  fmt.Println(&amp;quot;after: len(newSlice) =&amp;quot;,newSlice) &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: len(slice) = 10&#xA;after: len(slice) = 10&#xA;after: len(newSlice) = 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;指向Slice的指针&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果想修改slice header的内容，可以传递一个指向slice的指针，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func PtrSubSlice(slicePtr *[]int) {&#xA;  newSlice := *slicePtr&#xA;  *slicePtr = newSlice[0:len(newSlice)-1]&#xA;}&#xA;func main() {&#xA;  fmt.Println(&amp;quot;before: len(slice) =&amp;quot;, len(slice))&#xA;  PtrSubSlice(&amp;amp;slice)&#xA;  fmt.Println(&amp;quot;after: len(slice) =&amp;quot;, len(slice))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;before: len(slice) = 10&#xA;after: len(slice) = 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;作为方法的接收者，可以修改这个slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type path []byte&#xA;&#xA;func (p *path) TruncateAtFinalSlash() {&#xA;  i := bytes.LastIndex(*p,[]byte(&amp;quot;/&amp;quot;))&#xA;  if i &amp;gt;= 0 {&#xA;    *p = (*p)[0:i]&#xA;  }&#xA;}&#xA;&#xA;//ASCII letters to Upper&#xA;func (p path) ToUpper() {&#xA;  for i,b := rang p {&#xA;    if &#39;a&#39; &amp;lt;= b &amp;amp;&amp;amp; b &amp;lt;= &#39;z&#39; {&#xA;      p[i] = b + &#39;A&#39; - &#39;a&#39;&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;func main() {&#xA;  pathName := path(&amp;quot;/usr/bin/tso&amp;quot;)&#xA;  pathName.TruncateAtFinalSlash()&#xA;  fmt.Printf(&amp;quot;%s\n&amp;quot;,pathName)&#xA;  pathName.ToUpper()&#xA;  fmt.Printf(&amp;quot;%s\n&amp;quot;,pathName)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/usr/bin&#xA;/USR/BIN&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###容量(Capacity)&#xA;如何扩展slice的长度呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Extend(slice []int, element int) []int {&#xA;  n := len(slice)&#xA;  slice = slice[0:n+1]&#xA;  slice[n] = element&#xA;  return slice  //why return the modified slice?&#xA;}&#xA;&#xA;func main() {&#xA;  var array [10]int&#xA;  slice := array[0:0] // slice:[]&#xA;  for i:=0; i&amp;lt;20; i++ {&#xA;    slice = Extend(slice,i)&#xA;    fmt.Println(slice)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里运行的时候会报错，只会打印出前面10个数字，因为超过10的话已经超过了slice底层的array的长度，所以slice header还包含它的容量，表示其能表示的最大长度：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type sliceHeader struct {&#xA;  Length int&#xA;  Capacity int&#xA;  ZeroElement *byte&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当执行了slice := array[0:0]的时候，slice header如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := sliceHeader {&#xA;  Length: 0,&#xA;  Capacity: 10,&#xA;  ZeroElement: &amp;amp;array[0],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以通过内置的cap函数获得slice的容量：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if cap(slice) == len(slice) {&#xA;  fmt.Println(&amp;quot;slice is full&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Make&#xA;上面的例子中我们可以看到在要扩张slice的时候，这个时候我们就可以用内置的make函数来扩展我们的slice:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10, 15)&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;len:10, cap:15&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以让我们的slice扩展两倍：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10, 15)&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;newSlice := make([]int, len(slice), 2*cap(slice))&#xA;for i := range slice {&#xA;  newSlice[i] slice[i]&#xA;}&#xA;slice = newSlice&#xA;fmt.Printf(&amp;quot;len:%d, cap:%d\n&amp;quot;,len(slice),cap(slice))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;pirnt:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;len:10, cap:15&#xA;len:10, cap:30&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;make也可以只传递两个值，这样它的len和cap就是一样的了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := make([]int, 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice的len和cap都是10&lt;/p&gt;&#xA;&#xA;&lt;p&gt;make的时候是创建一个新的数组作为slice的存储，下面例子可以看出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s1 := make([]int,5,10)&#xA;s2 := make([]int,len(s2),2*cap(s1))&#xA;fmt.Printf(&amp;quot;s1.addr:%v,s2.addr:%v\n&amp;quot;,&amp;amp;s2[1],&amp;amp;s8[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;s2.addr:0x11701540,s8.addr:0x1170155c&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###Copy&#xA;在扩展的时候，我们可能需要复制一个slice到另一个slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Insert(slice []int, index,value int) []int {&#xA;  slice := slice[0:len(slice)+1]&#xA;  copy(slice[index+1:],slice[index:])&#xA;  slice[index] = value&#xA;  return slice&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice[i:]和slice[i:len(slice)]一样，slice[:]和slice一样&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###Append&lt;/p&gt;&#xA;&#xA;&lt;p&gt;自己创建一个Append来扩展slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Append(slice []int, elements ...int) []int {&#xA;  n := len(slice)&#xA;  total := n + len(elements)  //elements看以看作是一个slice,可以其计算长度&#xA;  if total &amp;gt; cap(slice) {&#xA;    newSlice := make([]int,total,total*3/2)&#xA;copy(newSlice,slice)&#xA;    slice = newSlice &#xA;  }&#xA;  slcie = slice[:total]&#xA;  copy(slice[n:],elements)&#xA;  return slice&#xA;}&#xA;&#xA;func main() {&#xA;  s1 := []int{0,1,2,3,4}&#xA;  s2 := []int{5,6,7}&#xA;  fmt.Println(s1)&#xA;  s1 = Append(s1,s2...)  //&#39;...&#39;是必须的&#xA;  fmt.Println(s1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;print:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[0,1,2,3,4]&#xA;[0,1,2,3,4,5,6,7]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;###内建的append&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上面是自己写的一个Append的函数，其实go中实现了一个内建的append，而且这个append对于任何类型的slice都可以append：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Create a couple of starter slices.&#xA;slice = []int{1, 2, 3}&#xA;slice2 := []int{55, 66, 77}&#xA;fmt.Println(&amp;quot;Start slice: &amp;quot;, slice)&#xA;fmt.Println(&amp;quot;Start slice2:&amp;quot;, slice2)&#xA;fmt.Printf(&amp;quot;slice[0]:%p,slice2[0]:%p\n&amp;quot;,&amp;amp;slice[0],&amp;amp;slice2[0])&#xA;&#xA;// Add an item to a slice.&#xA;slice = append(slice, 4)&#xA;fmt.Println(&amp;quot;Add one item:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&#xA;// Add one slice to another.&#xA;slice = append(slice, slice2...)&#xA;fmt.Println(&amp;quot;Add one slice:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&#xA;// Make a copy of a slice (of int).&#xA;slice3 := append([]int(nil), slice...)&#xA;fmt.Println(&amp;quot;Copy a slice:&amp;quot;, slice3)&#xA;fmt.Printf(&amp;quot;slice3[0]:%p\n&amp;quot;,&amp;amp;slice3[0])&#xA;&#xA;// Copy a slice to the end of itself.&#xA;fmt.Println(&amp;quot;Before append to self:&amp;quot;, slice)&#xA;slice = append(slice, slice...)&#xA;fmt.Println(&amp;quot;After append to self:&amp;quot;, slice)&#xA;fmt.Printf(&amp;quot;slice[0]:%p\n&amp;quot;,&amp;amp;slice[0])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过地址打印，我们会看到每次append之后返回的slice的地址都是不一样的，所以内建的append是会重新生成一个底层的array来持有数据的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###什么是nil&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go中如果一个slice是nil的，那么他的长度和容量都是0，并且它的起始地址是nil的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sliceHeader {&#xA;  Length: 0,&#xA;  Capacity: 0,&#xA;  ZeroElement: nil,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sliceHeader{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;需要注意的是它的起始地址为nil，如果一个slice是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice = array[0:0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;那么这个slice不是nil的，因为它有起始地址，nil的slice是没有地方给它存储元素的并且是不可以增长，但是nil的slice是可以append的，因为append会重新分配空间&lt;/p&gt;&#xA;&#xA;&lt;p&gt;###字符串(Strings)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;字符串可以看作是一个只读的字节(bytes)slice：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slash := &#39;/usr/bin&#39;[0]  //value is &#39;/&#39;&#xA;usr := &#39;/usr/bin&#39;[0:4] //value is &#39;/usr&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们还可以直接将byte slice强制转换成字符串&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;str := string(slice)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者反过来：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;slice := []byte(str)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当然，对于字符串还有很多，这只是一个简单的概述&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，我们了解了slice和array的基本结构，尤其是slice的实现原理，对于我们使用slice是非常有益的，尤其是内建的copy和append函数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参考资料：&lt;a href=&#34;http://blog.golang.org/go-slices-usage-and-internals&#34;&gt;http://blog.golang.org/go-slices-usage-and-internals&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Method Value和Method Expression</title>
      <link>http://www.wowzai.com/2014/method-value-vs-method-expression-in-golang.html</link>
      <pubDate>2014-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;根据调用者不同，方法分为两种表现形式：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;instance.method(args&amp;hellip;)  &lt;type&gt;.func(instance,args&amp;hellip;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中，前者为method value,后者为method expression。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两者的区别是method value绑定实例，method expression则须显示传参。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type User struct {&#xA;  id   int&#xA;  name string&#xA;}&#xA;&#xA;func (self *User) Test() {&#xA;  fmt.Printf(&amp;quot;%p, %v\n&amp;quot;,self,self)&#xA;}&#xA;&#xA;func main() {&#xA;  u := User{1,&amp;quot;Tom&amp;quot;}&#xA;  u.Test()&#xA;&#xA;  mValue := u.Test  //这里u是一个实例(instance)&#xA;  mValue()  //所以这里是method value，隐式传递receiver&#xA;&#xA;  mExpression := (*User).Test //这里*User是&amp;lt;type&amp;gt;&#xA;  mExpression(&amp;amp;u)//所以这里显示传递receiver&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;0x210030000,&amp;amp;{1 Tom}&#xA;0x210030000,&amp;amp;{1 Tom}&#xA;0x210030000,&amp;amp;{1 Tom}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;method value会复制receiver&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type User struct {&#xA;  id int&#xA;  name string&#xA;}&#xA;&#xA;func (self User) Test() {&#xA;  fmt.Println(self)&#xA;}&#xA;&#xA;func main() {&#xA;  u := User{1,&amp;quot;Tom&amp;quot;}&#xA;  mValue := u.Test  //立即复制 receiver,因为不是指针类型，不受后续修改影响&#xA;&#xA;  u.id,u.name = 2, &amp;quot;Jack&amp;quot;&#xA;  u.Test()&#xA;&#xA;  mValue()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{2 Jack}&#xA;{1 Tom}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>golang中defer的执行位置</title>
      <link>http://www.wowzai.com/2014/defer-in-golang.html</link>
      <pubDate>2014-07-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##golang中defer的执行位置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大家都知道golang的defer关键字，它可以在函数返回前执行一些操作，最常用的就是打开一个资源（例如一个文件、数据库连接等）时就用defer延迟关闭改资源，以免引起内存泄漏。例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func do() (ok bool) {&#xA;  file,_ := os.Open(&amp;quot;c:\a.txt&amp;quot;)&#xA;  defer file.Close()&#xA;  // doSomething&#xA;  return ok&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们可以在官方的文档中看到defer的执行顺序是逆序的，也就是先进后出的顺序：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; 5; i++ {&#xA;  defer fmt.Printf(&amp;quot;%d &amp;quot;, i)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;打印结果是：4,3,2,1,0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么再看这个例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func deferRet(x,y int) (z int){&#xA;  defer z += 100&#xA;  z = x + y&#xA;  return z + 50 // 执行顺序 z = z+50 -&amp;gt; (call defer)z = z+100 -&amp;gt; ret  &#xA;}&#xA;&#xA;func main() {&#xA;  i := deferRet(1,1)&#xA;  println(i)  // print 152&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我想这个例子已经能够让你明白defer的执行顺序了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>git自我教程</title>
      <link>http://www.wowzai.com/2014/my-git-manual.html</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;首先，需要说明的是这是写给自己看的，所以叫自我教程，这里只是记录我经常要用的一些命令，并且会持续更新，由于我最近刚刚开始使用git，所以很多东西还不懂的使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;初始化库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git init&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;增加文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git add &amp;lt;filename&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;提交文件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;comment&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;查看远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote -v &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;增加远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;eg:&#xA;&lt;code&gt;&#xA;git remote add wowzai git@github.com:wowzai/repo.git&#xA;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果发现远程库写错了，可以删除远程库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote remove &amp;lt;name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从远处库中拉取远程库到本地库：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git pull remote-repo-name&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;暂时我常用的一些git命令就是这些，对于像合并、建立分支我暂时还没用到，所以这里先不记录，等用到了再来了解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;持续更新中&amp;hellip;&amp;gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>那么穷为什么还要去旅行</title>
      <link>http://www.wowzai.com/2014/travel-really.html</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;要么读书，要么旅行，身体和灵魂总有一个在路上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这句话也无从考证最原始的出处了，不过有一个叫刘屈艳扬(http://baike.baidu.com/view/10466274.htm?fr=aladdin#作者简介)写了一本这本书《要么读书，要么旅行，身体和灵魂总有一个在路上》(http://book.douban.com/subject/24264880/)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;《身体和灵魂.总有一个要在路上》&#xA;&lt;a href=&#34;http://book.douban.com/subject/10806089/&#34;&gt;http://book.douban.com/subject/10806089/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在我小时候，那里是农村，那时候还能直接从沟里挑水喝，那是个无山但是水清的地方，但是那时候大家都很穷。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>关于最近</title>
      <link>http://www.wowzai.com/2014/2014-my-life-06.html</link>
      <pubDate>2014-06-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近工作很忙，哦，不，是一直以来工作都是很忙，好像一直都没有喘气的机会，自己心里总是想着这次把手头上的事情做完了可以好好休息一小段时间，调整调整，但是好像一直都没有机会喘口气，就这样一直忙呀忙，但是好像又什么都没有忙出来，瞎忙啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;去年的这个时候，涛哥离职了，说实话挺触动我的，我就在想我哪一天会从这个办公室走出去，可能再也不会走回来。转眼一年的时间过去了，工作强度似乎不减反增，除了周五，几乎每天都加班。每天手上有很多事情。忙碌的工作，一件事情做的不好，心里都不好受，但是又不可避免，心里压力好大。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;繁忙的对我最大的影响是记忆力下降，脑子记不住事情了，最明显的是水杯总是忘了，要么忘了盛水，要么是盛水了忘了带回来，还有就是脑子跟不上，总是两眼发呆，脑子感觉是空的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;工作似乎陷入了一个恶性循环，事情越多&amp;ndash;&amp;gt;手忙脚乱&amp;ndash;&amp;gt;心理压力大&amp;ndash;&amp;gt;忙中出错&amp;ndash;&amp;gt;事情越多，好像没有时间来好好梳理梳理，有个周末，惰性加一些乱七八糟的事情两天很快就过去了。然后周一又重复上一周的工作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于工作占用了我的大部分时间，再加上自己的时间管理差，导致我自己的计划无法开展开来，生活变得有一点点糟糕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一年的时间很快，眼看着涛哥离开，一年内自己想学的东西基本上一样都没有学成，明年的现在，我又能达到期望中的我百分之多少呢，同时合同也将到期，我还会留在这里嘛？ 天知道。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;哎，就是发发牢骚，其实心里挺难过的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Oracle中的执行计划</title>
      <link>http://www.wowzai.com/2014/oracle-explain-plan-1.html</link>
      <pubDate>2014-06-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Oracle中的执行计划&lt;/p&gt;&#xA;&#xA;&lt;p&gt;由于工作的关系，最近准备系统的学习一下Oracle相关知识，尤其是优化方面的东西，因为工作中可能会碰到性能问题，所以需要准备学习一下这方面的知识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;讲到Oracle的性能优化，首先想到的就是Oracle中的优化器。众所周知，Oracle中的优化器有RBO和CBO，由于RBO机会没有什么实际用处，这里就不赘述。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CBO中用到的两个概念：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;集的势&lt;/strong&gt;&lt;br /&gt;&#xA;Cardinlity表示对目标SQL的某个具体执行步骤的执行结果所包含记录数的估算，如果是针对整个目标SQL，那么此时的Cardinality就表示对该SQL最终执行结果所包含记录数的估算。&#xA;一般情况下某个执行步骤对应的Cardinality的值越大，其所对应的成本值往往也就越大，这个执行步骤所在执行路径的总成本值也就会越大。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;可选择率&lt;/strong&gt;&lt;br /&gt;&#xA;Selectivity = 施加指定谓词条件后返回结果集的记录数/未施加任何谓词条件的原始结果集记录数&lt;/p&gt;&#xA;&#xA;&lt;p&gt;补充：Cardinlity和Selectivity对于性能的影响&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;访问数据的方法&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;访问表的方法&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全表扫描： 从表所占用的第一区的第一块开始扫描，直到高水位。需要注意的是高水位并不会因为数据被delete了而降低，就像河中的水位线一样，即使退水了，留在岸上的水位线还在哪里，不会因此而降低（关于如何消除高水位，这又是另外一个问题了，后面再作讨论）。&lt;/li&gt;&#xA;&lt;li&gt;ROWID扫描：直接通过数据所在的ROWID定位并访问数据&lt;br /&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据用户输入的ROWID值去访问（较少）&lt;/li&gt;&#xA;&lt;li&gt;根据访问索引后的ROWID再回表访问对应的数据行记录（较多）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;访问索引的方法&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;索引唯一扫描：仅针对唯一索引的等值查找（=），即where条件中是唯一索引列的等值查询&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引范围扫描：唯一索引的范围查找（&amp;lt;、&amp;gt;、between等），非唯一索引where条件没有限制（不管是等值查询还是范围查询）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引全扫描：非空索引列的查询，查找是从最左边的叶子块的第一行，然后利用叶子块之间的双向指针链表，从左往右扫描索引块的索引行。因此索引全扫描是有序的，并且按照索引的键值列来排序，即走索引全扫描能达到排序的结果，同时避免对该索引键值列的真正排序操作。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引快速扫描：与索引全扫描相似，都适用于所有类型的B树索引（包括唯一性索引和非唯一性索引），扫描目标索引的所有叶子块的所有索引行。索引快速全扫描与索引全扫描有三点区别：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引快速全扫描只适用于CBO&lt;/li&gt;&#xA;&lt;li&gt;索引快速全扫描可以使用多块读，也可以并行执行&lt;/li&gt;&#xA;&lt;li&gt;索引快速全扫描执行结果不一定有序，因为此时是根据索引行所在的磁盘上的物理存储顺序扫描的，而不是根据索引行的逻辑顺序扫描的，所以扫描结果不一定有序（单个索引叶子块其物理顺序和逻辑顺序是一致的，但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序不一定在逻辑上有序）。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;索引跳跃式扫描：对于那些where条件中没有对索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标SQL，就像在扫描该索引时跳过了它的前导列，直接从该索引的非前导列开始扫描一样（世界并非如此）。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前导列的distinct值较少，非前导列的选择性好的情况。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Windows下查看端口和进程绑定</title>
      <link>http://www.wowzai.com/2014/Windows下查看端口和进程绑定.html</link>
      <pubDate>2014-06-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;windows下查看端口和进程绑定&#34; href=&#34;#windows下查看端口和进程绑定&#34;&gt;&lt;/a&gt;Windows下查看端口和进程绑定&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;最近准备开始学习Android开发，昨晚在用Eclipse开发，准备在模拟器上面跑程序的时候，报8700端口已经被绑定了，我很奇怪，心想难道是其他程序把8700端口给占用了？ 但是我还不知道如何查是哪个程序将8700端口占用了。于是上网查了一下如何查看端口和进程的绑定情况，这里做个记录，以备后忘，哈哈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.netstat -ano | findstr &amp;ldquo;8700&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;TCP     127.0.0.1：8700      0.0.0.0：0       LISTENING       6988&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其中最后一列的6988是对应进程的PID，然后再通过tasklist命令查找那个进程是6988&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.tasklist | findstr &amp;ldquo;6988&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;eclipse.exe     6988    Console         1       388,448K&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样通过简单的两个命令就能找出哪个程序将8700端口给占用了。这里，我可能不小心开了两个eclipse，导致第一个已经占用了8700端口，后面一个试图获得8700端口时就会报错。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇Blog</title>
      <link>http://www.wowzai.com/2014/new-born.html</link>
      <pubDate>2014-05-15 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;我的第一篇Blog&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;ndash;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我的第一篇blog,new born!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;加油吧，少年！&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>